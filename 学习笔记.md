<a name="fF81j"></a>
#### 前言
![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649211286319-b251116b-1551-4b11-b756-bbc028ca3902.png#clientId=u718e8b6e-c1e5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=374&id=u254e86c4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=1088&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119341&status=done&style=none&taskId=u56d962b3-82bf-4226-be1f-57e5fac0a84&title=&width=870.4)<br />vue分为两大部分，编译和运行时（如上图所示，左边的模块依赖右边的），上半部分compiler-dom和compiler-core是编译部分，将sfc（单文件组件）编译为js代码，并且将sfc中的template编译为render函数。之后交给下半部分的运行时去执行。

Vue运行时的核心，将顶层的组件逐层拆箱，直到全都拆成element类型（div,p,h1这些基本元素标签），最后用渲染器渲染到页面上。更新的时候，响应式的值改变时触发更新，再通过diff算法算出最小更新的点进行更新。

<a name="ks8Ho"></a>
#### 1.setup环境-集成jest做单元测试
按照jest官网[https://jestjs.io/](https://jestjs.io/)的文档，集成babel和typescript配置<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649297963750-5fa6667c-a98e-47e8-963e-189f1191faa8.png#clientId=uc2a6523a-3667-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=ufd64c771&margin=%5Bobject%20Object%5D&name=image.png&originHeight=398&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30106&status=done&style=none&taskId=u6f59f9a6-5331-4151-a784-827352c3030&title=&width=806.4)<br />**集成typescript，先yarn add typescript --dev 之后使用npx tsc --init初始化tsconfig.json文件**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649297980232-3b88cc66-d773-49f3-b02f-2b4944073810.png#clientId=uc2a6523a-3667-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=407&id=ub2f23968&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41422&status=done&style=none&taskId=u8aa5f084-70c4-4445-8f2c-9e203e33f67&title=&width=909.6)<br />将项目setup起来。

<a name="E6Nxh"></a>
#### 2.实现effect & reactive & 依赖收集 & 触发依赖
我们要实现响应式（reactive），就得依赖Proxy，拦截一个变量的get，set操作。<br />核心就是get中收集依赖，在set中触发依赖，这里的依赖不仅仅指b依赖于a，还包括b如何依赖a，当a变化的时候b需要怎么变化，所以这里的依赖可以叫作effect。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649323029998-37d18f15-638b-4bda-8e72-d0ae2618cd62.png#clientId=uc2a6523a-3667-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=139&id=u8a899df6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12710&status=done&style=none&taskId=u624ffb8d-bbe7-4d02-b835-8850937ede9&title=&width=298.4)<br />这里nextAge = user.age + 1就是一个effect。<br />我们用一个map来维护effect，每一个对象的key都对应一个effect组成的Set，为什么要用Set，因为依赖不能重复收集。上图中user.age实际上就触发了一次get，此时这个effect就被塞到对应的Set中了，之后在修改user.age时触发set操作，在set中触发依赖，执行对应的effect操作，这样nextAge的值也变了，我们就实现了一个最基本的响应式。

<a name="QFZhn"></a>
#### 3.实现effect.scheduler和effect.stop
接下来我们要是先的是effect.scheduler和effect.stop，为之后实现计算属性打下基础。<br />首先我们要让effect方法返回一个runner，这个runner是一个函数，其实就是我们给effect方法传的参数函数本身，所以我们要将effect.run方法return出去。<br />之后我们实现scheduler，达到响应式对象之后set的时候不会执行effect的第一个参数fn而是执行scheduler。实现方法就是通过effect的第二个option参数传进去，在ReactiveEffect这个类上新建一个scheduler属性存起来，之后在trigger的时候检查，如果有scheduler就执行scheduler，否则执行run。<br />最后实现stop和onStop，stop就是effect暴露的一个方法，当执行stop(runner)时，响应式触发更新就中止了，之后无论响应式对象怎么变，effect都不会触发，此时onStop方法会执行一次。实现方法就是类似scheduler，通过option参数传进去，再赋值给ReactiveEffect实例的stop和onStop，同时ReactiveEffect新增一个deps数组属性，用来存放该effect所在的deps，在track里 dep.add(activeEffect)的时候就把dep push到deps属性中。执行stop方法的时候就去遍历deps，把里面的当前effect全部删掉，这样trigger的时候就遍历不到这个effect了，触发依赖也就中止了。要重新启动依赖触发，就执行runner方法，因为runner方法里会触发get操作，就重新收集了一次依赖，这样响应式就又生效了。

<a name="b6m7g"></a>
#### 4.实现readonly和isReadonly&isReactive
这次我们实现readonly功能，和reactive方法类似，通过readonly(object)创建一个只读对象，只能get不能set。实现的方法很简单，只需要拦截set方法，返回一个警告就可以，但是这次我们可以重构一下代码，因为readonly和reactive都需要拦截get和set，所以可以吧他们公共的代码抽离出来，把handler抽离到一个baseHandlers.ts中，因为readonly和reactive的get大致相似，只是readonly不需要收集依赖，所以我们可以用一个高阶函数的技巧，创建一个createGetter方法返回get的handler方法，在创建get的时候传一个参isReadonly来区分，createSetter同理。并且我们发现，createGetter和createSetter方法不需要每次创建reactive/readonly对象的时候都执行一遍，我们可以将他们缓存下来：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649640771935-2933f7ed-c538-417c-9d6c-03868bab3727.png#clientId=u444babf7-f7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=62&id=u276b4451&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=501&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11715&status=done&style=none&taskId=u5c70dd17-9b81-459a-bd5b-9b529623ed6&title=&width=400.8)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649640781941-25b2974e-68a2-4979-b070-19979e4584e8.png#clientId=u444babf7-f7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=u2ff6701d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=334&originWidth=737&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31038&status=done&style=none&taskId=u23bb2d4e-f35a-4cff-8510-6896b999cae&title=&width=589.6)<br />这样重构完以后，我们在new Proxy的时候就可以直接调用baseHandler中的handler了，这时候我们可以继续优化，像new Proxy这样的低层次代码我们可以统一抽离到一个方法中。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649640904893-a9d2d840-c0c3-40aa-aa1d-bc15b42a7f0b.png#clientId=u444babf7-f7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=65&id=u679b1d01&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10254&status=done&style=none&taskId=u7ee85e8b-d7e8-41da-9c6b-65e8ea50c40&title=&width=407.2)<br />接下来我们实现isReadonly和isReactive，就是暴露这两个方法，传入一个对象就能知道他们是原始对象，还是响应式对象或者只读对象。实现方法很巧妙，因为我们现在通过reactive和readonly创建的对象都会拦截他们的get操作，那我们就在get操作里判断，设置两个特殊的属性<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649641154880-11bca933-519a-42d3-b75b-be267c8c44e0.png#clientId=u444babf7-f7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=86&id=u0eedb219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=107&originWidth=345&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8971&status=done&style=none&taskId=u1a539952-1d46-4bd5-9312-73184fabc95&title=&width=276)<br />在判断isReadonly和isReactive的时候就get这两个属性，并且在handler里面判断，如果是get这两个属性，就通过isReadonly来判断是否是响应式对象或只读对象。这里有个tips，要把get到的结果通过!!转换成boolean，因为普通对象是没用这两个属性的，返回的一定是undefined，把他转换成false就好了。

<a name="s9sVK"></a>
#### 4.优化stop方法
在之前的测试中，如果我们修改如下：![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649647241779-107c5cc0-a5e5-423a-8fea-cd98f82b5518.png#clientId=u444babf7-f7ad-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=41&id=ue54ec2f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2501&status=done&style=none&taskId=u07b3e41f-2167-49b0-9259-bd5540e962a&title=&width=158.4)<br />就会发现stop失效了，响应式依然会生效，原因就是obj.prop++实际上触发了一次get和一次set，触发set的时候又会触发依赖收集，所以我们在stop的时候清空dep就相当于白清空了。修改的方法是创建一个全局变量shouldTrack，在track的时候如果这个变量为false，就不执行依赖收集的操作。问题是这个shouldTrack应该放在哪里控制呢，答案是放在effct.run方法里面。为什么呢，来过一遍响应式的流程：首先定义一个响应式对象和effect，定义effect的时候会触发effect.run方法，这时候我们检查下有没有stop，肯定是没有的，所以赋值shouldTrack = true（shouldTrack默认值为false），执行effect.run的时候肯定会触发响应式对象的get，从而触发track，在track中检查shouldTrack，此时为true，收集依赖一切正常，收集完以后回到effect.run，切记要把shouldTrack = false，不然之后他一直为true就永远会收集依赖了。如果执行了stop，首先会去遍历删除effect.deps，并且active=false。之后再触发set的时候，遍历的dep是空，就不会执行effect.run，如果是obj.prop++这样先触发get再出发set也没问题，因为我们没有执行effect.run，shouldTrack 不会被赋值，此时shouldTrack 是默认值false，不会触发依赖收集。

<a name="dCBjB"></a>
#### 5.实现 reactive 和 readonly 嵌套对象转换功能
这次我们实现reactive和readonly嵌套转换功能，在之前的例子中，我们都是浅层的将对象转换为响应式对象，如果我们修改测试用例为：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649658511417-89c43aae-5516-44c4-b120-4af310715141.png#clientId=ub89cb6a8-e973-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ud70f914c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29010&status=done&style=none&taskId=uc0229353-73fd-4e1d-886e-07c207c3ecc&title=&width=453.6)<br />就会发现observed.nested并不是响应式对象，原因是我们在observed.nested触发的get操作里，返回的是Reflect.get(target, key)，这是一个普通对象，并不是响应式的。所以我们要在返回前判断一下，如果Reflect.get(target, key)返回的是一个对象而不是基本类型，就对这个对象再用reactive()包起来再return出去，readonly同理，这样就实现了嵌套转换。

<a name="A5CfQ"></a>
#### 6.实现shallowReadonly
前面我们实现了readonly的嵌套对象转换功能，但有的时候我们不需要把一个对象深层次地都变成响应式，这时候我们就需要实现shallowReadonly，即浅层次地把一个对象变成readonly，它深层次的对象还是普通对象。很简单，shallowReadonly和readonly只有get的时候返回的结果不一样，我们在createGetter里增加一个参数shallow，默认值是false，如果为true的时候代表创建的是shallowReadonly对象，get到的对象就是普通对象，就直接return<br />Reflect.get(target, key)即可。

<a name="g2uCM"></a>
#### 7.实现isProxy
阅读vue3文档<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649727852991-391e31ee-9f24-4aef-9504-6afcd6d98ce4.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u8dde776b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=730&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17358&status=done&style=none&taskId=u259d9e10-d126-4a4c-a5cc-e19d29ded64&title=&width=584)<br />我们这里暂时先实现对象是否为reactive何readonly，所以实现方法很简单，就是根据isReactive，isReadonly做一个组合判断：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649727918744-58a8b521-84c0-482a-8d63-e6fe4de60ff6.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=96&id=u0ceda3f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=120&originWidth=602&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12422&status=done&style=none&taskId=uc5fbd2b8-6edb-4f58-bab2-1d561998d3e&title=&width=481.6)
<a name="zNwGn"></a>
#### 
<a name="Sud9l"></a>
#### 8.实现ref
之前我们实现了reactive，但是reactive包裹的是对象类型的值，而number，boolean这样基本类型的值无法传入，因为proxy无法拦截基本类型数值的get，set，所以我们这次实现ref。基本思想就是实现一个类RefImpl，每次ref就创建这个RefImpl的实例，把值存放在RefImpl的value属性当中，改写这个类的get value()和set value()方法，在get的时候收集依赖，把依赖Set存在RefImpl实例的dep属性中，在set的时候触发依赖即可。这里有一些细节：收集依赖的时候要进行判断，类似reactive那边判断activeEffect是否存在，如果存在才收集依赖，因为有可能值触发了get而没有传入effect，此时activeEffect就是undefined；另外set的时候我们要对比上一次的val和这次set的val是否一致，如果一致再触发依赖。<br />最后我们再实现ref也支持传入对象类型的值，很简单，在constructor的时候判断一下val是不是对象，如果是就直接用reactive包一下即可。

<a name="vJ0Bq"></a>
#### 9.实现isRef和unRef
首先实现isRef，判断一个对象是否是通过ref方式创建的响应式对象，其实本质就是判断这个对象是否是RefImpl的实例，所以我们可以在RefImpl类内部创建一个属性__v_isRef=true，检测的时候就去检测是否存在这个属性并且为true，如果不存在就是false，这样就可以判断isRef。接下来实现unRef，就是一个方法，如果传入的是ref对象，就返回ref对象的value，否则就原封不动的返回。实现方式就是依赖上面实现的isRef先判断是否是ref对象，如果是就返回ref._val，否则就返回本身。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649819414169-363e4bc0-c9ae-475e-ac01-3dd504b641e7.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=74&id=u52b0155e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=92&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7893&status=done&style=none&taskId=u4639d4a3-f13a-4ade-b6ec-608e8490ec1&title=&width=332)

<a name="w6lHB"></a>
#### 10.实现proxyRefs
接下来我们实现proxyRefs，在使用vue3的时候我们发现，在template中使用ref会自动解包：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649819855043-170664b8-dfb1-48d6-aa53-ab89d442c8d6.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=407&id=uf05a7083&margin=%5Bobject%20Object%5D&name=image.png&originHeight=509&originWidth=731&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33070&status=done&style=none&taskId=ubdc9c16e-6d79-4096-854f-0daa435ffdf&title=&width=584.8)<br />这其实用proxyRefs实现的<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649819894887-3dedd2db-c0c3-43d2-8274-e8aa3c476f78.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=144&id=u20ef255a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=180&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25294&status=done&style=none&taskId=ue651ac2e-c230-46ed-98f0-c21c2170bd6&title=&width=361.6)<br />我们创建一个对象user，并通过ProxyRefs创建这个user的副本，之后我们就可以用proxyUser.age直接拿到age，而不需要通过age.value。我们可以发现，proxyUser.age本质上触发了get操作，所以我们可以用Proxy来实现，并且拦截get操作，在get获取到的值如果是ref类型，就返回ref的value，否则就正常返回，可以发现这就是我们上节实现的unRef，所以直接return  unRef(Reflect.get(target,key))就好了。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649820130619-77c31b91-4a8b-47c0-ab5a-6c752f47adc0.png#clientId=ub72bde56-6bf9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=124&id=u6e710538&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=399&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28345&status=done&style=none&taskId=uc10325fd-65ad-4d94-8f13-7aca85c0017&title=&width=319.2)<br />接下来我们要拦截set，在通过proxyUser改变属性时，要保证改变后这个属性依然是响应式的。所以我们分情况，一般情况下我们都直接执行替换，即Reflect.set(target,key,value)就好了，但有一种特殊情况就是这个属性原来是ref对象，给它赋值一个普通对象，这时候我们不能简单替换，因为一旦替换这个属性就不是响应式对象了，所以我们得target[key].value = value，将改变的结果赋给这个属性ref的value。这里要注意，我们改变Proxy对象的时候，他代理的原始对象user也是会跟着改变的，所以user.age.value可以拿到最新的值。

<a name="epTkX"></a>
#### 11.实现computed计算属性
根据vue官方文档，计算属性传入一个类似effect中fn的方法，返回一个结果，并将这个结果缓存起来。当依赖没有发生变化，这个方法就不会再次执行，返回的是上一次缓存的结果。首先我们需要实现一个computed方法，接收一个函数，这个函数中必须包含一个响应式对象<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650004413523-ee1b2742-93bc-486f-8b33-6206a6807557.png#clientId=u51e10148-2292-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=132&id=ud520cd7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=165&originWidth=410&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16425&status=done&style=none&taskId=u453a93e4-a27c-42dc-af09-4345442ff91&title=&width=328)<br />类似于实现ref，我们可以创建一个类ComputedRefImpl，这个类接收一个getter方法作为构建方法的参数，并且实现一个get value()方法，返回这个getter方法的执行结果。这是第一步，接下来我们要实现缓存，我们可以引入一个私有属性_dirty，初始值是true，当为true时认为依赖“变脏”了，需要重新执行一遍getter计算结果，计算完成以后将_dirty=false，认为依赖是“干净”的，并且将结果赋值给一个私有熟悉_value，之后每次访问value都返回的是_value。这样实现了仅有第一次需要执行getter，我们还需要在依赖发生改变后重新执行getter。回想起我们当初实现reactive的时候实现了一个effect.scheduler，当响应式依赖发生变化的时候，执行的都是scheduler方法而不是effect.run，所以我们可以在构造方法里初始化一个ReactiveEffect，并且传入一个scheduler方法<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650004991765-7ad943e9-48e5-4fc1-942c-d9b65a9ea030.png#clientId=u51e10148-2292-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=ud332fb6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19301&status=done&style=none&taskId=u9cc4a307-10a6-425c-9686-fb9ea5dc25b&title=&width=647.2)<br />这个effect的作用就是：当响应式依赖发生改变的时候，都执行scheduler方法，将_dirty=true，这样之后get value的时候，因为_dirty是true，都会去重新执行一次getter方法，否则依赖不变化就不执行getter，返回缓存。

<a name="XHt9r"></a>
#### 12.实现初始化component和element主流程
今天我们来实现vue的运行时，首先我们按照vue语法来写一个组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650252147043-16bc502f-fe5b-44f2-9995-5a57eea45aad.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=u71dcc45e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26887&status=done&style=none&taskId=u8f5c6161-3f84-4120-ba4a-e6d4200dc03&title=&width=485.6)<br />然后我们在main.js中要在container中挂载这个组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650252191084-4d03149d-5151-4d2a-b393-fa4c6bc8946a.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=81&id=u5e5606ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=101&originWidth=607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11607&status=done&style=none&taskId=u46bd3b9c-98fb-4d81-807c-b69720f9ce8&title=&width=485.6)<br />所以我们要实现一个createApp方法，createApp方法返回一个对象，对象中有一个mount方法，接下来我们就实现这个mount方法即可，mount中首先要实现一个createVNode方法创建一个vnode，这个vnode其实就是一个描述组件或者dom属性的对象<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650252504682-05fb9904-634b-4fc8-a72a-1943455b97ff.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=68&id=u5039aec8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=85&originWidth=379&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6609&status=done&style=none&taskId=uf5be54a4-d603-424f-b051-b36fe2f798a&title=&width=303.2)<br />上图就是一个element类型的vnode，创建完vnode以后我们再实现一个render方法去渲染组件，在render方法中会首先去调用一个patch方法，这个patch方法就是渲染的核心方法，他会被递归的调用多次，从父组件开始，一层层地往里patch，在patch中我们先判断组件的类型，通过vnode.type，如果是字符串就是一个element，那么我们就直接调用mountElement方法把他渲染到页面上：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650253566097-2ee240fa-6621-47d2-b428-c82fa57995ad.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=418&id=u010f6f3d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=749&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62055&status=done&style=none&taskId=uaa1ad5e3-11a1-4484-9733-b6407163a5d&title=&width=599.2)<br />如果vnode.type是object，说明他是个组件，那么我们要继续解析这个组件，首先我们根据vnode创建一个组件实例：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650253691797-ff926500-71d9-40a2-be54-64b8a01313c9.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=u35391e98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14092&status=done&style=none&taskId=u89ec8037-6d6b-4fb1-8858-3d4698f3db6&title=&width=451.2)<br />接下来我们根据实例instance初始化组件，目前比较简单，就是执行组件内的setup方法返回一个结果stateResult，把结果挂载到instance上，之后执行组件的render方法，其实就是调用createVNode生成一个subTree树形结构的vnode树：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650254401052-9c68fa04-5155-4950-a5f4-793d105abed0.png#clientId=u8911aaa7-56ea-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=127&id=u39c4d3a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=452&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12080&status=done&style=none&taskId=uc8a5e9e7-ba77-48ac-ba1d-93ed2f4aebd&title=&width=361.6)<br />接下来我们继续对这个subTree调用patch方法，这里就进入了渲染element的过程，因为这个subTree的类型是字符串"div"，这样，我们就实现了一个最基本的渲染方法。

<a name="yAqvv"></a>
#### 13.用rollup打包库
上一节我们实现了component基本的初始化流程，然后我们也写了一个example，但这个example肯定是跑不起来<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650202771660-29dde981-3d2b-43df-b896-c09038a6111d.png#clientId=ub010593f-ea44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=79&id=u544999ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=485&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6259&status=done&style=none&taskId=ufd54af86-cda6-4dfc-87ed-317d944a70e&title=&width=485)<br />因为我们还没有引入createApp,h这些api，并且我们也不能直接引用源码里暴露出来的方法，我们需要用打包工具对我们的代码进行ts转码，并打包成符合浏览器要求的js库。这里我们使用rollup，为什么不用webpack，其实也可以，webpack更多地用来打包web应用，而rollup更多地是用来打包库，并且rollup的配置相对webpack也更简单一些，首先我们安装rollup和rollup用来转换typescript的插件：yarn add rollup @rollup/plugin-typescript --dev，然后我们在根目录新建一个rollup.config.js，因为rollup是支持esm语法的，所以我们直接export default，非常自然。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650203288590-ca54a247-3d35-461b-8730-243de0c89088.png#clientId=ub010593f-ea44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=491&id=u80bcd347&margin=%5Bobject%20Object%5D&name=image.png&originHeight=491&originWidth=525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24263&status=done&style=none&taskId=uc1811390-8ff6-411d-9fdc-cd4a69d0656&title=&width=525)<br />这里我们配置了一个入口文件，并且配置了两个出口文件，一个是commonjs规范的cjs.js，一个是esm规范的esm.js，我们把这两个文件名都提取到package.json中，然后配置typescript插件就可以了。之后我们在package.json中加上build的script<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650203525452-534cf039-bbed-42c9-b4c1-2d0c183f3cf3.png#clientId=ub010593f-ea44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=100&id=uee1f36f2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=100&originWidth=441&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4594&status=done&style=none&taskId=uac33d5f2-532e-4eae-99bd-244f7729b21&title=&width=441)<br />并且把我们源代码中的方法都集中到一个index.ts中export出去<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650203587942-46b37c60-bea9-4721-8b53-2f8b845d27d0.png#clientId=ub010593f-ea44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=105&id=u319eb69e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=466&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6364&status=done&style=none&taskId=ubefc9081-47f1-4169-9e20-a7aae88f973&title=&width=466)<br />之后运行yarn build就可以打包了，如果报错就再安装一下tslib：yarn add tslib --dev。<br />最后我们会打包出两个文件<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650203734815-46e282f7-8e57-4499-9bba-2f1d2bec811b.png#clientId=ub010593f-ea44-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=71&id=u5bee6bdf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=71&originWidth=297&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2724&status=done&style=none&taskId=u9ac5becb-9ccd-4592-9a08-360813e6675&title=&width=297)<br />在index.html中引入就可以愉快地使用了。

<a name="sjWtx"></a>
#### 14.实现组件代理对象
之前我们实现了基本的渲染流程，但是渲染的都是静态的节点，现在我们要在组件内部渲染setup中定义的data，效果如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650363621115-21b8a50a-525d-4474-8dd0-64131b0384b9.png#clientId=u6c308a7d-b208-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=416&id=ud46c4005&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22338&status=done&style=none&taskId=u552bf5ee-0c26-4535-811a-27e9db84594&title=&width=626)<br />我们发现需要在render方法里获取this.msg，但是现在render函数的this上肯定是什么都没有的，需要我们挂载一下，我们又可以发现，这个this.msg就是setup里return对象的msg，之前我们已经在组件instance上挂载了setup返回的结果setupState，也就是说我们需要把这个setupState对象里的属性都挂载到render方法的this上，要怎么挂载呢，我们可以用一个proxy代理对象，当获取this.msg时其实就可以触发这个代理对象的get，所以我们可以先在instance上创建一个proxy属性，他的值是一个proxy对象：![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650368459632-62a988b5-e891-47ee-8529-d0cd65a64074.png#clientId=u6c308a7d-b208-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=167&id=uce973aa4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=167&originWidth=514&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14006&status=done&style=none&taskId=u4170300a-6a9e-4ee1-8e94-873b1eed555&title=&width=514)<br />在拦截的get方法里，我们去遍历setupState，如果setupState里有我们需要的key，就返回setupState[key]，之后我们把proxy对象挂载到render函数上：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650368552207-114f743e-1e2e-4a48-87e1-b3ec2ba9fc8c.png#clientId=u6c308a7d-b208-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=42&id=u2d34be66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=42&originWidth=442&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4960&status=done&style=none&taskId=u42ae9421-b813-45a6-9068-059add14d5a&title=&width=442)<br />这里我们使用了call，把render方法的this指定为proxy，这样proxy上的属性，即setupState上的属性就能够通过在render方法里用this拿到了。<br />接下来我们实现this.$el，vue文档中说明this.$el可以拿到组件的根dom节点，上面我们已经实现了this代理对象，之后我们就可以在proxy的get里添加更多的属性，比如当key==='$el'时，我们就返回根dom节点，但是这个dom我们目前无法获取，需要先绑定到instance实例上，所以我们先在instance实例上添加一个el属性<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650425277099-df070ae2-49d3-46f0-bd96-3fd28fe1a6c0.png#clientId=u789f02b5-f305-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=166&id=u332c4b8f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15000&status=done&style=none&taskId=ua6967a87-877a-4ffd-bb98-224a02c2730&title=&width=405.6)<br />之后我们需要在mountElement的时候把根dom节点赋值给vnode.el<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650425339782-28ccbd50-f06e-49eb-bf58-7868e3fa9d08.png#clientId=u789f02b5-f305-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=38&id=u356a75d5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=47&originWidth=470&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9495&status=done&style=none&taskId=u7d1b5cd1-f496-4639-87b2-c402444ab8f&title=&width=376)<br />到这里还不够，现在我们赋值的vnode是element的vnode，而我们代理对象的this是在component上的，component类型的组件instance上没有赋值el，所以我们需要在setupRenderEffect里进行赋值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650425693614-bc9385e5-3de4-4576-8997-ee2d968663f5.png#clientId=u789f02b5-f305-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=uc7daa0a6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=275&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33209&status=done&style=none&taskId=u84388db9-7a46-4513-b492-8c2b151a0d0&title=&width=520)<br />我们在patch之后进行赋值，因为patch结束后整个组件都已经被转换成了纯element元素组成的树形结构subTree，此时这个subTree肯定是element类型的，所以他的el肯定是有值的，赋值给instance.vnode.el，这样组件instance.el就有值了，之后我们在proxy的get里拦截，如果key是$el，就返回instance.vnode.el。<br />接下来我们队代码进行重构，把proxy的handler提取到一个单独的文件里，这时候就涉及到一个问题，我们get里使用了instance，如何把instance传到这个handler里呢。我们可以通过给target对象添加属性的方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650426124425-a556d673-e9e0-4c89-a6d0-ef7a31125cbb.png#clientId=u789f02b5-f305-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=33&id=u9196ca6c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=41&originWidth=708&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9928&status=done&style=none&taskId=u2523da30-2442-4971-a450-29fbd4827c5&title=&width=566.4)<br />在target上新增一个_属性，值是instance，这样我们在handler里就可以用_接收到了。<br />同时我们可以用策略模式，用一个map来维护key和返回值的关系，这样就省得写一堆if else了<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650426246400-679e6dde-e86c-4ec7-a833-7228c2ef458b.png#clientId=u789f02b5-f305-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=uac13ba7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41752&status=done&style=none&taskId=u561359e6-9d55-45f7-9a78-258d8cf6d09&title=&width=432.8)

<a name="ZiHj2"></a>
#### 15.实现shapeFlags
之前我们实现了组件渲染，我们在渲染一个元素的时候会去判断他本身的type是element还是component，如果他是element我们还会判断他children的类型是text children还是array children，之前我们是用type是字符串还是object类型这样去判断的，那么这次我们可以用一个对象的形式：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650680984830-4cefa2e7-dccb-4d23-9905-997038cb85a1.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=164&id=u9ebfc958&margin=%5Bobject%20Object%5D&name=image.png&originHeight=205&originWidth=448&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35322&status=done&style=none&taskId=u5636eb50-eab5-4bea-af1b-7373fdaedc0&title=&width=358.4)<br />如果是element类型，shapeFlags.element = 1，其他同理，这样我们就可以通过判断shapeFlags这个对象来判断类型了。但是这样不够高效，在vue中我们会使用位运算符来进行判断，我们构造这样一个结构:<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650681089239-937a3800-feb7-4149-a101-425010eee92c.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=123&id=ua8417adf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=408&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43118&status=done&style=none&taskId=ud7ff3a29-f06a-4c24-958a-4080bb16e14&title=&width=326.4)<br />用四位数代表这个shapeFlags对象，如果0001就相当于shapeFlags.element=1，这样我们通过赋值这四位数和比较这四位数就可以实现快速的判断，那么怎么进行赋值呢，通常我们使用&和|位运算符。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650681231335-92c89b17-97b4-4369-9c18-2da328bf8040.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=68&id=u57136993&margin=%5Bobject%20Object%5D&name=image.png&originHeight=85&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21667&status=done&style=none&taskId=ub8e8a637-1576-442b-b28b-8a752bb5390&title=&width=309.6)<br />赋值的时候我们用0000 | 你想要赋值的数字，比如0000|0001=0001;<br />判断的时候我们使用&，源数字 & 比较数字，比如我们想检测最后一位是否是1，1001 & 0001 = 0001 ，结果为0001，那么结果就是真，如果最后一位不是1,1110 & 0001 = 0000，结果为0000那么就是否，这样我们就可以进行查找。<br />搞懂了原理接下来我们创建一个ShapeFlags.ts，里面创建一个枚举<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650682402782-47519d21-2e92-4e40-9406-8e777e2235e9.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=138&id=u5720d2d3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=173&originWidth=442&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16489&status=done&style=none&taskId=uf7f5bef7-2e8a-4289-8554-7eb9a43467e&title=&width=353.6)<br />这里我们使用了左移位运算符<<，他的意思就是把二进制数往左移指定位数，左边超出的位数会清除，右边的补零，比如 00000101 << 2 就是 00010100。所以上面我们用左移位运算符就实现了0001,0010,0100,1000。<br />接下来我们可以去修改之前的代码，把之前renderer.ts中判断组件类型的逻辑用位运算改写，在vnode上新建一个shapeFlag属性，在初始化的时候通过判断vnode.type进行赋值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650685520332-231fc1d0-f542-4098-99e2-141a3a8b1d31.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=177&id=u33bbdf02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20170&status=done&style=none&taskId=u7c76ea70-5195-4701-bcfb-f102454be6f&title=&width=448.8)<br />并且之后判断children的类型也放到vnode里：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650685694213-de23debd-e116-438b-8333-1c91d5cae155.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=134&id=udf8fad1b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=167&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24967&status=done&style=none&taskId=u1c92ece1-3a14-4d5b-80b1-3b13a041592&title=&width=532.8)<br />这里因为shapeFlag已经有值了，就是追加赋值，通过|运算符实现。<br />之后在renderer里原先判断的地方，我们就改成通过&运算符进行判断：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650685850965-3a92eb44-942d-418a-8ff8-d734f26f856b.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=168&id=u402d529c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=580&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29325&status=done&style=none&taskId=u67bdc653-5fc8-46af-9848-fa205d8c0e5&title=&width=464)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650685861950-16edda13-9968-4e3d-96ee-a0ac5cad8677.png#clientId=u5a167760-efd3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=uc9177106&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57360&status=done&style=none&taskId=u01398194-e802-499a-9547-859aa33ee39&title=&width=619.2)<br />这样，我们就通过位运算符实现了元素类型判断的功能，位运算符因为是基于二进制数的，所以在底层执行的速度是非常快的，性能上会更好，但也有个缺点就是可读性不高。

<a name="YjRUO"></a>
#### 16.实现注册事件功能
之前我们已经实现了props添加id，class这些属性的功能，现在我们需要添加事件，回想vue中我们在render函数中注册事件的方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650703057815-43344dd3-86f4-4d18-8e26-04109a5277d4.png#clientId=u4f6e6fcc-18ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=302&id=uf4110671&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24956&status=done&style=none&taskId=uf6e261e8-1f45-44b9-954f-d6cbdeb8b15&title=&width=442.4)<br />那么我们需要在注册props的时候进行一个判断，如果是事件就给element绑定事件：跳转到mountElement方法中，在遍历props的时候进行判断。那么我们该如何区分一个props属性是否是事件呢，我们观察到，事件都是以“on”+ 首字母大写的事件名来命名的，那么我们可以写个正则来匹配一下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650703272306-6efee4f1-b4ac-4c78-9da5-086630ee4ab0.png#clientId=u4f6e6fcc-18ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=30&id=uce659b3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=37&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6435&status=done&style=none&taskId=u83c24d1f-873d-4826-bed3-1f55c194bde&title=&width=364.8)<br />用这个方法来判断是否是一个事件，如果是的话我们需要把props的key转换为真实的dom事件名，其实就是把key前两位的“on”去掉，再转换为小写就好了，所以我们可以这样写：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650703404333-c110ff0e-e28a-4127-b1a2-e2a8f98373c6.png#clientId=u4f6e6fcc-18ff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=116&id=u425f8478&margin=%5Bobject%20Object%5D&name=image.png&originHeight=145&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15628&status=done&style=none&taskId=ub7b55949-28be-4122-a377-65cfec8ed63&title=&width=457.6)<br />这样我们就实现了绑定事件。

<a name="BPEk0"></a>
#### 17.实现组件props
上节我们实现了注册事件功能，现在我们来实现父子组件props传值，首先我们按照vue的写法，新建一个Foo组件，他在setup中接收一个{count:number}这样的props：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650721905151-8950683a-825b-4cc6-8b3e-0d56ec02b6a4.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=261&id=ua8c715ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16547&status=done&style=none&taskId=u063f9095-d58b-4354-856a-c4416322ddd&title=&width=592)<br />之后我们在App中引用它，并给他的props传值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650721952674-df76496d-f303-40a8-b740-8bffaa8b5265.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=69&id=ue0465e66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=69&originWidth=319&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2574&status=done&style=none&taskId=uc8610544-a6e5-4deb-b1f4-e3d10ff029f&title=&width=319)<br />此时我们可以在Foo的setup中打印一下props.count，会发现是undefined，因为我们在setupStatefulComponent中调用组件setup方法的时候没有传参，所以我们现在要给他补上参数，怎么补呢，在setupStatefulComponent方法中我们可以拿到组件instance，所以我们就要在组件instance上挂载props，而props目前又存在于vnode.props上，所以我们就实现一个initProps方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650722424665-76d856db-11ed-4983-8816-ba4de01f96e8.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=uc24bfd9f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=130&originWidth=962&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12468&status=done&style=none&taskId=uc838f4b4-fc5b-40da-b825-1f44e95b616&title=&width=962)<br />这里要注意vnode.props有可能是undefined，因为组件本身可能就没有props，要给一个空对象默认值。<br />现在我们在setup方法里打印props.count就有值了，下一步我们需要实现在render方法中能通过this.count拿到这个值，回想起我们之前实现组件代理对象的时候创建了一个proxy对象，我们只需要在这个proxy对象handler的get方法里新增就好了，之前我们只是在setupState中查找是否有我们需要的key，现在我们再去instance.props里也查找一下就好了，我们先实现一个在对象中查找key的方法hasOwn：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650722840623-88647e17-30a6-43da-a693-3ce2ebb15afc.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=84&id=uc19e50f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=84&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9554&status=done&style=none&taskId=u6830fdd6-ffeb-4736-94fa-792f3c8ff15&title=&width=761)<br />之后我们在handler里面加上：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650722916540-1ec02fef-8f72-4cf2-b08d-d9e298de6de9.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=376&id=ue533d5df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=376&originWidth=562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30128&status=done&style=none&taskId=u1afe7ec9-8eff-4ca3-b307-18c5ef4e26e&title=&width=562)<br />然后我们在页面里就可以看到this.count被正确渲染出来了。<br />最后还有一步要实现，props是不能被修改的，vue这里对props的处理是浅层的只读，所以我们要用到之前实现的shallowReadonly，在setup的时候把instance.props转换为shallowReadonly对象即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650723092383-eb7b7097-23e5-4806-9a89-a28f9156344b.png#clientId=u3fec74fd-6a16-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=ua38c81a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11041&status=done&style=none&taskId=uaa5dd582-76ed-45de-b25f-07e0e19aa82&title=&width=694)<br />这里就体现我们上面给instance.props默认值的作用了，如果是undefined的话这里shallowReadonly(undefined)就会报错，接下来我们可以尝试在setup中修改props.count，会发现无法修改并console.warn（之前设置的警告）。

<a name="uIJCX"></a>
#### 18.实现组件emit
vue中子父组件传值是用emit自定义事件，我们来写一个简单的组件例子Foo：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650800495380-e1033583-b227-4f2c-b0de-3bf4204df972.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=412&id=u33d486cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=412&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24715&status=done&style=none&taskId=u1b2969ca-e82f-4210-9719-9a4ce4638b5&title=&width=548)<br />在Foo中定义了一个btn，点击后触发自定义事件add和add-foo，之后我们在App中引入Foo<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650800549932-af4d494a-5b1e-4769-91b1-8b9ebeb1dd93.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=469&id=uae4a104e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22378&status=done&style=none&taskId=u63016d73-40cd-43aa-9ab1-219c74e4935&title=&width=598)<br />在创建Foo的时候props中指定接收add事件的方法onAdd和onAddFoo。<br />首先我们要实现在Foo的setup方法中，第二个参数是一个对象，其中有一个属性emit是一个方法，用这个方法来触发自定义事件，所以我们要在setupStatefulComponent调用setup方法的时候多传一个参数，但是现在我们组件instance上还没有emit这个方法，所以我们要在instance上进行挂载，在创建instance的时候我们给定一个emit方法，并且我们把这个方法提取到一个单独的文件中，这时候我们可以先写一个特定的例子：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650806446144-8f6ebafd-ed27-4605-b05d-4c164a2ecc02.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=99&id=u0a9f47f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=616&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43198&status=done&style=none&taskId=u91d00ff1-418d-4f9f-a245-ee43cc3d14b&title=&width=616)<br />从组件instance的props中找到名字是onAdd的方法，然后执行。这时候我们发现，instance此时并不存在，我们需要用参数传到这个方法里，我们可以利用bind的偏函数功能：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650806536035-83c7e203-563d-4ba2-a4aa-090483babe5f.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=37&id=ua0677326&margin=%5Bobject%20Object%5D&name=image.png&originHeight=37&originWidth=546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4573&status=done&style=none&taskId=u5438a8ec-8234-4143-9ed3-82968229528&title=&width=546)<br />这样写，instance就会作为emit的第一个参数，而其他的参数则向后移动一位（[参考链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E7%A4%BA%E4%BE%8B)），这样我们就可以用 function emit(instance,event,...args) 这种写法来接收instance了。<br />实现写死的情况后我们来实现通用方法，我们注意到，传进来的event名字是“add”，而我们在props中存在的事件方法名字是“onAdd”，我们需要给event前面加上on，并且让他的首字母大写，同时，我们还支持add-foo这样的事件名，他对应的方法名是onAddFoo，其实就是先把add-foo转换为addFoo，然后在执行上面的首字母大写方法，于是我们实现这样的字符串处理方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650806783624-1b0f288b-bfbc-46c6-a430-049bbee05dc7.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=299&id=u0d7acd94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=755&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26446&status=done&style=none&taskId=ua7f2b5f1-9e17-4a53-8249-4f5bf2cdcc1&title=&width=755)<br />之后在emit中调用：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650806803516-38b3de00-94ed-40c2-a97a-b75840f9a19c.png#clientId=uc73f4042-e28b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=171&id=ucfa26423&margin=%5Bobject%20Object%5D&name=image.png&originHeight=171&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12588&status=done&style=none&taskId=u11058ae2-2677-4e82-8045-52471b8d6fb&title=&width=500)<br />上面的...args是为了实现自定义事件传参：emit('add',1,2)然后触发onAdd(1,2)，这样我们就实现了组件emit。

<a name="cUmvB"></a>
#### 19.实现组件slot
这一节我们来实现组件slot功能，所谓slot就是组件插槽，子组件提供一个或多个插槽，由父组件指定内容传给子组件，子组件就把内容渲染在插槽中，看起来就像这样，父组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650895569529-0301a155-f87f-4117-8cb2-339677f3190b.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=417&id=uc98c52b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23397&status=done&style=none&taskId=u43b8884c-655b-4f51-9f68-f3206adf333&title=&width=784)<br />子组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650895553866-63e0a0ff-ba7e-4c8a-8f8a-e38571727081.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=380&id=ub975e969&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27144&status=done&style=none&taskId=ud6117253-a6e2-4990-a5b4-41a66c6ba25&title=&width=694)<br />当然这是最终版本的效果，我们可以先从简单的实现起来，首先我们发现，插槽内容是通过子组件的children传进来的，所以我们要在子组件通过this.$slots拿到children并且渲染到页面上，首先我们要先去我们的组件代理对象proxy上新增一个$slots属性，他返回的是组件vnode.children，为了保持统一，我们先去组件instance上创建一个slot属性，初始值为一个空对象，然后我们来到setupComponent这里，新增一个initSlots方法，这个方法现在实现的功能很简单，就是把vnode.children赋值给instance.slots，我们可以看到页面上渲染出了内容，这样一个最基本的slot插槽功能就实现了。<br />但是用户有可能children传的是一个数组，这时候如果我们这样写：h('div',{},[this.$slots])，就会发现无法渲染，因为这个数组里放的必须都是虚拟节点vnode，所以我们需要把这个数组转换为vnode，转换方法就是用h包一下：h('div',{},[this.$slots])，这样又不是完全可以的，因为这样非数组又不行了，所以我们得加个判断，统一包装成数组，然后都用h方法进行处理：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650896410845-a4ff54c1-d01c-4b9e-ae28-aae403feeab0.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=95&id=ud2fdb0f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=503&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6202&status=done&style=none&taskId=uf3eeb14a-d287-4efb-928a-7e77da52685&title=&width=503)<br />这个处理方法我们封装成一个叫做renderSlots的方法，并export出去，这样可以在渲染函数中直接使用。<br />接下来我们实现具名插槽功能，所谓具名插槽，就是可以给插槽位置起名字，这样外部指定好之后就能把内容渲染到指定的插槽位置中，这时候我们renderSlots方法就需要改写一个，加一个参数name指定插槽的名字，然后父组件中传递的内容children要改成一个对象，key是插槽name，value是插槽内容。源码改起来也很简单，只需要去initSlots方法中，把原来简单的赋值操作改成一个遍历操作就好了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650897036985-698bdf04-fa2c-4f25-b682-8c1e1204cdcc.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=270&id=u5f8ec9e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=755&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79202&status=done&style=none&taskId=u418d6447-a2fb-4ffe-817b-b36c213b93f&title=&width=755)<br />遍历一下children，然后生成一个对象slots，key是插槽name，value是vnode，这样我们在子组件中就能通过name在this.slots中拿到指定的内容并渲染到插槽中了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650897150398-6c82d7f9-34fc-43e7-8545-4a74d6daa220.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u3531eaef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73674&status=done&style=none&taskId=ucefc3908-51ad-42bb-8da8-ade05dd7434&title=&width=680)<br />最后我们来实现作用域插槽，所谓作用域插槽就是：如果你的插槽内容是动态的，而且依赖于父子组件的数据，由于内容是写在父组件中的，拿不到子组件的数据，这时候就要实现一个方法，让子组件的数据能够暴露给父组件中写的插槽内容。这时候我们的例子就变得和最上面的截图一样了，我们在子组件中定义一个变量age，这个变量作为renderSlots方法的第三个参数传进去，之后我们在父组件中把虚拟节点改写为一个函数，该函数接收一个对象参数，这个对象参数就是我们renderSlots方法传出去的第三个参数，那么该如何实现呢，首先既然我们把父组件的虚拟节点改写成了一个函数，那么我们在initSlots里面遍历拿到的value就不是vnode了而是一个函数，函数的执行结果才是vnode，所以value要改写成value()，并且value(props)的参数是子组件传过来的遍历{age:1}，所以我们要指定props，方法就是继续把slots[key] = value()也改写为一个函数返回value()：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650898169197-8b628b4e-1930-4f68-9b28-39123b3345d9.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=106&id=u6f10d139&margin=%5Bobject%20Object%5D&name=image.png&originHeight=106&originWidth=589&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9109&status=done&style=none&taskId=u8163a088-35b7-480d-84f4-e000c5f8a1e&title=&width=589)<br />这样我们就可以在生成value，也就是vnode.children的时候，指定他是一个函数，传入renderSlots的第三个参数props，这样就可以在initProps中接收到了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650898421684-6f91ad74-f31b-4b18-86bb-9cc998330b9b.png#clientId=ucf52d200-0337-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u782c817e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20399&status=done&style=none&taskId=u28e1ad26-3608-4c97-a652-fa973446aa7&title=&width=689)<br />我们在页面中可以看到子组件中定义的变量age渲染到了页面中。<br />最后的最后我们再来进行一个小优化，我们在initSlots的时候发现，并不是所有元素都有插槽内容的，所以我们可以在这里加一个判断，仍然是使用我们之前创建的ShapeFlag来进行位运算，我们添加一个SLOT_CHILDREN = 1 << 4，之后在创建vnode的时候判断下：如果元素是组件类型且有对象类型的children，我们就认为他是有插槽的组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650943530821-41769b65-6825-4762-bdc7-8694ec03fd75.png#clientId=u24878c5b-1d6e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=151&id=u5da40946&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=531&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14696&status=done&style=none&taskId=u3dfa23f0-0ad7-473c-939c-9eb83fd9749&title=&width=531)<br />之后我们在initSlots时就可以先判断一下该组件的类型，如果确实有slot children再进行操作：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650943580796-57bcb82e-cc25-43d7-bb16-8b89036bafac.png#clientId=u24878c5b-1d6e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=126&id=ud92d93e0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=126&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12043&status=done&style=none&taskId=u9405a859-a2db-4b37-abdb-f14e3898ebe&title=&width=550)

<a name="Fyl7J"></a>
#### 20.实现Fragment类型节点
上一节我们实现slot的时候有个问题，我们在renderSlots的时候为了处理children可能是数组的情况，都用一个div把children包了起来：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650959170069-b484cd79-a2c8-477a-b3fe-fbbfde23fd65.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=36&id=u09fa7c70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=36&originWidth=462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4651&status=done&style=none&taskId=u8196b87e-8bd9-402e-b3f1-3c2a90304d8&title=&width=462)<br />这就导致了每个插槽内容外层都多了一个div节点，这其实是没必要的，今天我们实现Fragment类型节点就能解决该问题，所谓Fragment节点就是没有根节点，只渲染children内容的一个节点，那么实现起来也很简单，首先我们在renderSlots里把createVNode改成创建Fragment类型的vnode，接下来我们来到renderer.ts里的patch方法，在这里先判断一下vnode.type，如果是Fragment那么我们就进入processElement(vnode, container)方法中，这个方法实现的功能就是渲染vnode的children到container中，而我们有一个现成的方法mountChildren，直接使用即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650959530604-6f5354d9-ee2c-4e32-ac2a-98204466c722.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u9efdad83&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=435&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7561&status=done&style=none&taskId=u1d57ae56-a0f2-4044-8812-d901d6895b5&title=&width=435)<br />接下来我们在页面结构里，就能看到slot内容外面的div元素消失了。<br />那么我们能否优化一下呢，我们注意到renderer.ts和renderSlots.ts中都使用了一个字符串'Fragment'，这个字符串我们应当用一个全局变量约束起来，这里我们在vnode.ts中新建一个Symbol类型的全局变量Fragment<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650959639269-4984d62e-9a87-41f4-8335-bbe1839bec72.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=70&id=u5c7f5861&margin=%5Bobject%20Object%5D&name=image.png&originHeight=70&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7409&status=done&style=none&taskId=ub03d9b37-28c9-4714-8733-a5376706a3e&title=&width=474)

<a name="p71HR"></a>
#### 21.实现Text类型节点
这一节我们来实现Text类型节点，所谓Text类型节点就是一段单纯的文本，没有html标签包裹，如下图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650964791719-4f080eab-dbe0-4dce-a932-ccc80dfad1ea.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=81&id=u0fc33b88&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=419&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3736&status=done&style=none&taskId=u68d421c2-3e74-49a5-99d1-98bcf5d60ca&title=&width=419)<br />我们先修改App.js，创建text节点需要一个新的方法createTextVNode，传入一段文本作为参数：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650964973875-30c0c73d-9697-4a29-81e3-cea7f91b75fd.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=463&id=u85b145b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=463&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30560&status=done&style=none&taskId=u31d5f88e-b2b5-4b8f-814f-81382fab935&title=&width=735)<br />我们首先在vnode.ts中定义一个Text类型节点，和上节的Fragment一样使用Symbol，然后我们定义createTextVNode方法，这个方法就是创建一个Text类型的vnode，之后我们去renderer.ts中，在type类型判断中加个如果是Text类型就执行processText方法<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1650965135988-5ac607ef-df46-4afb-b510-13368ac9755a.png#clientId=u434ee66a-4290-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=167&id=u24be8e80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=167&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15210&status=done&style=none&taskId=u5ecbd240-a0be-4782-a0f9-d5dccbb2090&title=&width=655)<br />这个方法拿到vnode的children，即文本内容，然后创建一个textnode，把文本传进去，再追加到container上就可以了，这里注意要把document节点赋值给vnode.el，这是为了this.$el能够拿到元素本身（和之前mountElement一样）

<a name="K8hFi"></a>
#### 22.实现getCurrentInstance
这节我们来实现getCurrentInstance方法，这个方法只能在组件setup()中调用，获取当前组件instance，那么我们就来到调用setup方法的地方，component.ts中的setupStatefulComponent这里，首先我们定义一个getCurrentInstance方法，return当前的组件instance，那我们要怎么拿到instance呢，可以定义一个全局变量currentInstance，在调用setup方法前给它赋值，调用完setup后重置为null即可。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651026105724-53334843-b4fc-4416-bf94-3c561e2fc01f.png#clientId=uc8ee90b8-5273-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=ua8f98bd5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=117&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9504&status=done&style=none&taskId=u7ff710a2-0608-4d06-8269-bac10cf7e4d&title=&width=320)<br />这样我们在控制台就可以打印获取当前组件instance了，接下来我们优化下代码，我们的赋值操作可以用一个<br />set方法封装一下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651026146381-28918967-3cbb-459f-95c7-a6cd77b9cbb6.png#clientId=uc8ee90b8-5273-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=91&id=uffc9f3ac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=391&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8071&status=done&style=none&taskId=u630748e7-2811-41f7-969d-6bcdf19f8f7&title=&width=312.8)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651026157113-29438fa4-460d-4c1f-903e-28960e8ae099.png#clientId=uc8ee90b8-5273-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=145&id=u6cabbd7a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=181&originWidth=606&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22965&status=done&style=none&taskId=u18f57b46-cdad-4d73-ab6e-a19307ad0f4&title=&width=484.8)<br />为什么要封装呢，因为这样我们就可以跟着currentInstance的变化，如果不封装且发生错误时，代码里有很多这样的赋值操作，我们无法得知是什么时候赋的值，而封装了set方法以后，我们只需要在set方法里打一个断点就能追踪instance是何时变化的了。
<a name="T6WGD"></a>
#### <br />
<a name="nFnDJ"></a>
#### 23.实现provide-inject
在vue中，provide-inject是用来实现跨组件传值的，最外层组件provide一个对象，在他的子孙组件中就都可以通过inject拿到这个对象的值。我们先来实现一个简单的demo：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053237963-2bcbf9c9-bf54-4c8a-bf7d-faad60323dfb.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=459&id=u879ea076&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49177&status=done&style=none&taskId=ue1ebbf8c-5ee6-4a37-b33c-705c31b76c0&title=&width=765.6)<br />父组件在setup中provide了两个变量，在子组件中去取，所以我们首先实现两个方法:provide和inject，provide接收两个参数key,value，把值存在一个对象中，inject方法根据key去这个对象中取。我们可以在组件instance上创建一个对象provides来实现这一点，要拿到组件instance，可以借助上一节我们实现的getCurrentInstance方法，因为我们provide和inject都是在setup中调用的，所以getCurrentInstance可以正常地拿到当前组件实例。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053514387-75652a32-e076-4cd7-a601-437d11524418.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=119&id=uab53035b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17624&status=done&style=none&taskId=u29e12421-d4bb-4180-a852-4100fb9fa9b&title=&width=397.6)<br />接下来我们要是先inject，目前我们就两个组件，所以子组件获取一下他parent组件的provide就可以了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053588780-0cbe1a15-df94-44c8-b6d5-48ddbd06ec3a.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u550aa08b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=139&originWidth=544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15450&status=done&style=none&taskId=u7cb2af20-a9de-41ff-abc5-fcc7def5e5d&title=&width=435.2)<br />但是目前instance上面目前没有parent属性，我们需要加一下，并且是通过createComponentInstance的参数传进来：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053641086-50f12ced-9bb5-4a5c-8f94-c1d7b494872b.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=292&id=u19d7b557&margin=%5Bobject%20Object%5D&name=image.png&originHeight=365&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41961&status=done&style=none&taskId=u803f5e00-f0ab-4e7f-9b34-2d05a515d77&title=&width=813.6)<br />这会影响很多方法，我们都一一更改一下，比较无脑，就是一层一层通过参数传下去，有两个地方比较特殊：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053785665-8ddf9faa-1d02-4ad7-8f09-6c6c2e0118da.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=85&id=u87fa780a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=106&originWidth=459&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11445&status=done&style=none&taskId=u5a613380-d474-4783-a855-6606a448924&title=&width=367.2)<br />入口的render方法里，根节点是肯定没有parent的，所以我们要给一个null<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651053819977-53c9583d-ec3c-46a9-a98c-a5b27e1d9ece.png#clientId=ub520daab-af4e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=221&id=u2b5f9d8f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33564&status=done&style=none&taskId=u1e0402ad-e243-4a22-842f-1fac8860870&title=&width=578.4)<br />在patch子组件时，parent就是当前组件instance本身，所以这里是instance。<br />到这里，我们最简单的两层provide-inject就实现了，但是这个实现方案肯定是有问题的，我们稍微改写一下App.js，添加一个ProviderTwo组件，使得Provider不再是Cosumer的父组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651138482775-55bb8b7e-f041-48ad-abf3-efe63319ff24.png#clientId=uaca91a8c-b6b8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=423&id=u73cbbd69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49924&status=done&style=none&taskId=u4265be98-31a5-494f-bd6d-f315c18bb65&title=&width=824.8)<br />这时候页面上打印的值就是undefined了，很显然此时Consumer的parent上的provides啥都没有，那么我们可以这样做：在初始化instance的时候如果组件有parent，就把parent.provides赋值给当前组件的provides，这样最外层的provides就一层一层地往里传了下去，子孙组件就能拿到provides中的值了。<br />接下来我们再次更改App.js，我们在ProviderTwo上也创建一个provide，且key与Provider中的同名，并且我们在ProviderTwo上通过inject获取foo，按照vue中设计的provide，一个组件inject一个属性foo，应当先去父组件上找，如果没找到再往父组件的父组件上找，直到找到为止，所以如果有重名的provide应当优先用父组件的。按照我们目前的写法肯定是不行的，我们再ProviderTwo中修改了provides并且我们初始化组件provides是用的赋值操作：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651139317743-de68dc11-6b6c-4aa4-8fab-1b02955c4bfe.png#clientId=uaca91a8c-b6b8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=34&id=u606fa14c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=43&originWidth=427&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4991&status=done&style=none&taskId=u32322127-59ac-489a-8a23-e46d01feda4&title=&width=341.6)<br />这会导致我们修改了provides就会影响到parent.provides，所以现在provides上的foo属性被全部修改并覆盖了。要解决这个问题，我们联想到了原型链，这和组件一层一层往外找provide不是很相似么，所以如果一个组件修改了provide，我们就不能简单地引用parent.provides了，得修改一下当前instance的provides，我们来到apiInject.ts中修改provide方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651139791389-cc35aa2a-36d1-40e5-ae7c-c34c3ba02247.png#clientId=uaca91a8c-b6b8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=32&id=uf6d73f30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=40&originWidth=597&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7766&status=done&style=none&taskId=u4d650124-7c88-44c2-9418-b8f5afc0791&title=&width=477.6)<br />Object.create的意思就是把parentProvides作为原型，创建一个新的对象，并且我们把这个对象赋值给provides<br />和currentInstance.provides，这样当前组件的provides就能通过原型链找到父组件的provides，并且他本身也可以添加任意属性且不会覆盖父组件的provides，刷新一下页面发现一切正常。<br />之后我们再优化一下，因为provide方法可能在setup中被调用多次，我们不应当每次都给currentInstance.provides重新赋值，会导致覆盖，我们需要加一个判断：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651140106422-64cf85f4-4d94-42cc-82fe-2198822eab60.png#clientId=uaca91a8c-b6b8-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=136&id=u6e083648&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=733&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21862&status=done&style=none&taskId=ud9c2c407-ecec-4454-a5d4-a795e1382e7&title=&width=586.4)<br />当第一次调用provide方法时，当前组件provides和父组件provides肯定是一样的，每调用一次provide方法，我们就会在provides上修改或新增key属性，那么这个provides就一定不再和父组件provides一样了，因此我们可以以这个为判断条件，避免重复初始化。<br />最后还有一个小功能，inject方法支持传入一个值或者函数作为默认值，如果找不到对应的provide就使用这个默认值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651154771499-a7c6f661-59b9-4a35-a571-d9aca38492f4.png#clientId=ucabf0fd1-a1af-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=59&id=uac170661&margin=%5Bobject%20Object%5D&name=image.png&originHeight=59&originWidth=515&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8020&status=done&style=none&taskId=u7917ab52-25e2-46fb-bcbc-7e95f21eba4&title=&width=515)<br />实现方式很简单，我们修改inject方法，接收一个默认值参数，去parentProvides中取值时首先遍历parentProvides的key，如果存在该key则返回value，否则就返回默认值，如果默认值是function，就返回function执行结果。

<a name="kNUOu"></a>
#### 24.实现自定义渲染器custom renderer
我们之前实现的vue运行时，都是运行在dom环境中的，其实vue支持自定义渲染器，只要提供平台特定的创建节点，更改api，就可以让vue运行在不同的环境中，我们回到renderer.ts中的mountElement方法，这里写的是我们把vnode渲染到页面上的内容，我们把这些内容移到几个方法中，然后我们通过参数把这些方法传到renderer.ts中，在需要渲染的时候执行这些方法即可。知道了思路我们来具体实现，首先创建一个runtime-dom目录，在里面新建一个index.ts，在这里我们创建三个方法，并且把renderer.ts中的内容拷贝过来：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651203722006-12796f7f-3e5f-4b2c-be4a-47a6bb198445.png#clientId=udb3a69ad-281f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=u7185de08&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=618&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42035&status=done&style=none&taskId=u1d798df5-edb0-474c-a72d-efbb845367c&title=&width=494.4)<br />这三个方法分别实现了创建元素，创建props属性，插入元素的操作，之后我们要把这些方法传到renderer.ts中，接下来我们改写一下，本来renderer.ts里面是一系列方法，最终暴露出去一个render方法，我们现在用一个_createRenderer_方法包起来，接收一个option参数，这个option就是我们定义的createElement,patchProp...方法，之后就可以的mountElement里调用了<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651204279388-212b3646-9e84-4e9e-9677-35cb40bd527d.png#clientId=udb3a69ad-281f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=489&id=u24f232a4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=611&originWidth=700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84114&status=done&style=none&taskId=u08d87473-f6a7-47d0-ace4-078ba1bf51c&title=&width=560)<br />注意，到这里我们export了一个createRenderer方法，但是这个方法没有返回值，而我们在createApp.ts中之前是使用了render方法的，所以现在我们要把render方法传给createApp。依然是用来了函数传参的思想：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651204726990-01efc7dd-0720-4bf7-bb46-b3d25028d3a2.png#clientId=udb3a69ad-281f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=301&id=u5176b976&margin=%5Bobject%20Object%5D&name=image.png&originHeight=376&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30840&status=done&style=none&taskId=u75cd33e4-7c13-4ace-ad79-7ab96b86b98&title=&width=436)<br />在原来的createApp方法外面包一个createAppApi方法，接收一个render参数来调用，这样我们在renderer.ts中，就可以通过调用createAppApi拿到原来的createApp方法了，最后return出去即可。<br />接下来我们修改一下runtime-core入口文件，首先我们要export _createRenderer_方法供runtime-dom调用；原先我们是从createApp.ts中获取createApp方法的，现在已经改成了通过createAppApi获取，并且runtime-core现在应该只作为运行时的核心模块，不暴露具体的createApp方法，应当由runtime-dom模块暴露：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651205042643-b02129bc-dd68-4489-b9ef-0598180c71c3.png#clientId=udb3a69ad-281f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=124&id=uac003f8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=155&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20955&status=done&style=none&taskId=u4ac22a82-e566-4d22-a721-7bed7f2fe8f&title=&width=540)<br />此时，createApp方法就已经由runtime-dom模块暴露了，之后不要忘记修改一下整个mini-vue的入口文件index.ts，加上一行把runtime-dom模块暴露出去：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651205148983-c9913a0c-4dd4-491a-95c3-653a6dc2ac05.png#clientId=udb3a69ad-281f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=34&id=u139411e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=42&originWidth=446&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3497&status=done&style=none&taskId=u8c00e148-5c52-47ed-8152-89d7fba6c15&title=&width=356.8)<br />我们注意到runtime-core在这里就没必要暴露了，因为他是runtime-dom依赖的上层模块，我们可以移动到runtime-dom中的index.ts中。接下来打开helloworld例子，页面是正常显示的，说明我们的修改没有问题，这样我们就把dom渲染器抽离到了runtime-dom模块中。<br />接下来我们就可以利用刚刚抽离的_createRenderer_方法去创建一个自定义的渲染器，来把组件渲染到canvas上，我们新建一个例子，引入一个在页面上绘制2D游戏的库PIXI，<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651286602440-dd63b69d-0b11-4d19-ac6b-ea77182ff8f6.png#clientId=uf53c8a4d-c995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=108&id=u52ac70eb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=135&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13047&status=done&style=none&taskId=uf6e0d576-594a-4910-8f99-3a34b2db235&title=&width=400)<br />之后我们利用_createRenderer_来创建我们自定义的创建element，patchProp，insert方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651286646362-e96e22bc-0c71-4de8-99bc-180cfb821288.png#clientId=uf53c8a4d-c995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=u055e901c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41219&status=done&style=none&taskId=u8b73632a-ac15-436b-8dd4-9c7b356215c&title=&width=446.4)<br />最后我们用_createRenderer_返回的renderer创建一个App，并挂载到画布上，上面的写法都基于pixi官方文档。<br />现在我们来实现App组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651286769475-6928486b-14da-43bd-86ce-c3932d61941d.png#clientId=uf53c8a4d-c995-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=245&id=u88b7fe1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19286&status=done&style=none&taskId=ud696c682-0753-4df3-8d25-ed5aa2d2b10&title=&width=432.8)<br />这个组件很简单，就是创建了一个rect组件，并且设置了几个props属性，之后我们运行，就能看到canvas上有红色的色块内容了，这就说明我们用vue组件的写法正确地实现了在canvas上渲染。

<a name="NeE7X"></a>
#### 25.更新element流程搭建
之前我们都是在做vue运行时的初始化流程，这节开始我们来实现更新流程。首先创建一个简单的demo：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651461093928-b6af122b-933b-4426-b134-6ed2e0d92c12.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=550&id=u4fe6faf9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=550&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34626&status=done&style=none&taskId=u6a7a5a9b-fa7a-4665-ba72-0c3a0743afc&title=&width=691)<br />一个组件App，setup中初始化一个响应式对象count和一个改变count的方法，在render中渲染一个div显示count的值和一个button触发onClick事件。这里我们在组件中使用的ref，所以要去reactivity的index.ts中把ref暴露出去，同时我们注意在render中我们使用ref时直接使用的this.count，并没有使用this.count.value，这就是vue文档中说的自动解包，我们要来实现一下。我们在之前实现了一个proxyRefs方法，这个方法用于解包一个对象中的ref，如果对象的一个属性是ref，就返回ref的value，所以我们在component初始化setupState的时候直接返回proxyRef的setupState就好了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651461662232-d13f47bd-4af3-4c6d-b8b6-14e6dbc0be95.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=88&id=u1a70cc2c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=479&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8135&status=done&style=none&taskId=u32c6953e-570d-44f7-95d2-3a671cc1c18&title=&width=479)<br />接下来我们来实现更新，更新的本质其实就是在render的时候拿到上一次渲染的vnode树，和本次渲染的vnode树进行一个比较，然后更新需要变更的dom元素，所以我们要想办法拿到上一次的vnode树，观察renderer.ts发现，我们是在setupRenderEffect方法中通过instance.render.call(proxy)拿到subTree的，这个subTree就是vnode树，我们现在要在响应式对象count变更的时候触发instance.render，重新返回一个新的vnode树和旧的进行比较，问题是怎么触发呢，回想之前响应式的部分，响应式对象每次变更的时候会触发effect.run，所以我们只要用effect把这部分代码包起来就可以了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651462192727-724027aa-dc3d-4c5a-9bdf-9baa0c5410d2.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=u43c4be30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81320&status=done&style=none&taskId=u401297e9-a5ee-4d32-adce-9f3f2af890c&title=&width=656)<br />我们在执行instance.render方法的时候会获取this.count，这就是一个依赖收集，所以之后每次count变化的时候都会触发依赖，也就会执行effect.run，就会重新执行instance.render生成一个vnode树，这样我们就实现了响应式对象变化的时候重新生成vnode树。我们现在观察页面，发现点击按钮了以后页面会往下追加新的div节点，因为我们现在没有判断是更新还是初始化，每次变化都会执行patch方法去mountElement，所以我们这边加一个判断条件isMounted，挂载在instance上，初始值为false，即没有初始化，如果没有初始化才执行上述代码，并且执行完后将isMounted改为true，这样之后就不会重复mountElement了。<br />同时，我们需要存储一下旧的vnode树，留着和新的来进行比对，所以我们在instance再新增一个subTree属性，用来存储上一次渲染的subTree。现在我们来改写一下patch方法，之前的patch方法就接收一个vnode，将他新增渲染到页面上，现在我们要接收两个vnode：n1,n2，n1代表旧的vnode树，n2代表新的，之后来实现比对逻辑，因为改写了patch，所以patch里面调用的processFragment，processElement，processComponent...这些方法我们都要把vnode参数改写成n1,n2，目前仅仅是改写参数，具体实现先不用管。调用patch的地方我们也改一下，我们认为，如果n1是null，那就说明是初始化，所以我们setupRenderEffect方法改写的最终效果就是：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651462938935-73898cb8-3a7f-4a3d-9235-79a318ea1b95.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=600&id=u84ef3fd3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55748&status=done&style=none&taskId=ud2024f80-d985-44bb-bc66-3f305b9bcd5&title=&width=806)<br />初始化时patch的n1参数是null，更新时则是上一次渲染的subTree，在render方法中因为是入口方法，一定是第一次渲染，所以n1参数也是null：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651463020821-f7b0d75b-f2c7-463b-aa03-20ce77bc4713.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=91&id=ud6063c1f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=579&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7867&status=done&style=none&taskId=uf779e701-5047-475b-a7fb-e7b1f099374&title=&width=579)<br />接下来我们简单实现一下processElement方法，判断一下n1是否为null，如果是执行mountElement初始化方法，如果不是执行一个patchElement更新方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651463141554-7ec0f6fe-8a36-4a57-b6d4-6257f5c10998.png#clientId=ue42b9dee-b287-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=u8469baad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11705&status=done&style=none&taskId=ua68a592d-06c7-4fd0-b61e-a2649f9e881&title=&width=612)<br />patchElement方法目前不作实现，简单console一下n1,n2看下效果即可，我们点击页面的button，发现可以进到patchElement方法即可，本节的流程搭建就已完成。

<a name="Mhc06"></a>
#### 26.更新element的props
上一节我们实现了更新流程的搭建，本节我们首先实现更新element的props，我们改写一些update例子中的App.js：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651672298609-4d1af0b9-4a6b-4045-b691-5bc5c0b3c002.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1152&id=uc7218d77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1152&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93500&status=done&style=none&taskId=ud7307b3f-3e02-45ba-811c-d74e0939e1d&title=&width=827)<br />在上面的例子中我们设定了3个props改变的场景：<br />1.props某一项的值发生了改变<br />2.props某一项的值变成了undefined或null<br />3.props删除了某一项的值<br />我们通过三个按钮绑定三个事件来演示这三个场景。<br />首先我们来实现值发生改变的场景，在之前我们已经实现到了patchElement方法，拿到了改变前后的两个vnode：n1和n2，然后我们可以取到两个vnode的props，我们创建一个patchProps方法来处理props，我们现在需要找到props的哪一项发生了改变，很简单，我们遍历newProps，每一项和oldProps对比，如果发生了改变，就执行变更props的操作，但是我们目前只实现了挂载props的操作，就是我们在实现自定义渲染器那节提取到runtime-dom模块中的hostPatchProp方法，这个方法目前只接收el,key,val三个参数，无脑地对el进行setAttribute挂载属性操作，现在我们需要改写一下，把val改成传入两个参数：一个preVal旧的prop属性，一个nextVal新的prop属性，直接把nextVal set给el即可，然后我们要调用这个方法。我们会发现改写后#root上的props都变成了undefined，这是因为我们在mountElement时也调用了hostPatchProp方法，这里我们也要改一下，直接第三个参数oldProp传null即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651674371160-eabff00d-d326-497b-bbc4-3c38f49c1e2a.png#clientId=ubd69c027-4bb0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=36&id=udce7fc77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=36&originWidth=312&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3301&status=done&style=none&taskId=ud655c068-4e88-4b5a-a82a-cb709cf2790&title=&width=312)<br />回到patchElemeent，目前我们在patchElement中还没有el，要拿到el就必须去vnode上获取：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651673183648-344ae973-6738-4594-bc02-a0491be3a201.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=54&id=ue53f9536&margin=%5Bobject%20Object%5D&name=image.png&originHeight=54&originWidth=389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4157&status=done&style=none&taskId=uc40d807c-7a7e-467d-a174-a9951f32a59&title=&width=389)<br />这里要注意，我们给vnode赋值el属性的操作是在mountElement中，所以只有n1的el有值，n2还没有，我们要赋值给n2.el，否则在下一次patchElement n1.el就是undefined了。<br />有了el，那么我们直接调用runtime-dom中的patchProps就好了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651673316883-f0bbddc7-ab60-4bef-9193-457836c2d7fa.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=u2f5b4dea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=157&originWidth=457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12146&status=done&style=none&taskId=ub5098193-66db-4c20-8293-e6a711152f4&title=&width=457)<br />接下来我们实现第二个场景，props.foo变为undefined或null。那么我们hostPatchProp中的newProp就为undefined或null，我们判断一下，如果是这两个值就removeAttribute：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651673563594-81a24f00-b8be-4c81-b819-622947c0507e.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=112&id=uca1c93c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=445&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7218&status=done&style=none&taskId=uc5fdd511-2684-4f7e-bf19-c5dd2c86485&title=&width=445)<br />这样就剩下第三个场景了，这个场景我们需要遍历oldProps，如果发现某一个key在newProps中是不存在的，就和第二个场景一样removeAttribute，所以我们直接调用hostPatchProp，newProps传null就好了<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651673692585-d883a5eb-6f47-40c1-8aae-aa407672b8e8.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=133&id=u0cb89b69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=133&originWidth=487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9303&status=done&style=none&taskId=uc8192499-fe07-495e-a499-fd2f4ede78e&title=&width=487)<br />写完之后我们去测试页面，打开控制台，观察一下#root元素上的属性，分别点击三个按钮，看上述场景是否都正常。<br />最后我们有几个地方可以优化一下，首先我们在遍历oldProps之前可以检查下oldProps是否为空，如果为空就没有必要遍历了，所以我们加个判断，但是这里注意，我们不能对对象进行!=={}的判断，因为对象是引用类型，即使他是空的，也一定不会全等于{}，所以我们可以创建一个空对象的引用EMPTY_OBJ，在初始化oldProps的时候如果不存在就给一个EMPTY_OBJ的默认值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651673969341-aaade7d5-dc33-454d-9f52-0f876360744d.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=61&id=uc436e1cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=61&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6431&status=done&style=none&taskId=u42bb7759-893c-484d-ab54-223d10d2317&title=&width=387)<br />之后检查也是利用这个EMPTY_OBJ进行判断：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651674020173-4b4ede46-2efe-4f40-b230-5d12cd30ed69.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=174&id=u8f606d9c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=516&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11659&status=done&style=none&taskId=ube5b3b0f-57d5-4222-a1e2-5d317dae7d7&title=&width=516)<br />另外一个优化点在于，如果我们在patchProps时一开始就发现oldProps和newProps是相等的，就没必要进行所有的操作了，vue官方做法是用全等进行判断，但是我认为这是无效的，因为既然已经进入到了patchProps，说明已经生成了两个vnode树，他们的props一定是不同的引用对象，我提了一个PR：[地址](https://github.com/vuejs/core/pull/5857)<br />**更新：尤大已回复我的PR，他提到在vue的compiler模块会提升组件的props对象，实现夸渲染复用，所以这里oldProps和newProps实际上是同一个引用，可以进行===对比（学到了）**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651674096242-0454c987-581a-4cfd-a378-2fd1bf0bf52a.png#clientId=u835753df-1959-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=40&id=u934768d0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=40&originWidth=296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3850&status=done&style=none&taskId=u501e8e9d-45b9-472b-9808-7b5c37d734a&title=&width=296)

<a name="X1RBX"></a>
#### 27.更新element的children
本节我们来实现更新element的children，之前我们实现element的时候知道element的children一共有两种类型：一种是text类型，一种是array类型，代表children子元素是一系列element或组件，那么element改变就应该有4种场景：

1. array -> text
1. text -> text
1. text -> array
1. array -> array

为了模拟这四种场景，我们新建四个组件，在App.js中分别引入，首先我们来看下ArrayToText.js<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651801286274-dcd6d533-b973-4748-9fd5-978935f1d5f3.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=426&id=ubb6e1586&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=893&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50589&status=done&style=none&taskId=u123a4fc5-ed98-4b0b-b133-0b2f199407c&title=&width=714.4)<br />我们创建了一个响应式变量isChange，并把他挂载到window对象上，这样我们在控制台操作window.isChange=true就可以实现响应式变化，从而观察到组件children从array变成text。<br />具体实现我们来到renderer.ts中，上一节我们在patchElement中实现了patchProps，我们现在在这里实现一个patchChildren方法，先传入两个参数n1,n2，我们首先要通过shapeFlag拿到n1和n2的类型，通过if-else进入我们当前要实现的array->text流程。既然children是从array变成了text，那我们要做的就是先卸载子组件，再挂载新组件，所以我们写一个unmountChildren方法用来卸载子组件：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651801834591-016a0aea-2f02-4be8-b305-c6657f57de46.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=115&id=u87a12697&margin=%5Bobject%20Object%5D&name=image.png&originHeight=144&originWidth=380&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11834&status=done&style=none&taskId=u51cede8b-08f5-4505-8ed4-b8e41573d03&title=&width=304)<br />遍历children，拿到每个children.el，就是他们的真是dom，然后执行remove操作，这个remove操作类似我们之前实现的hostCreateElement，hostPatchProp一样，是runtime-dom中实现的，我们来到那里，remove方法本质就是dom的removeChild操作：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651802038809-a5e79b6a-099d-47df-bbf1-529087ad3c1c.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=119&id=ud4179c12&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=406&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14253&status=done&style=none&taskId=ubcc2bdb3-2bf7-4bc8-b4fe-cdb949cf172&title=&width=324.8)<br />这样我们卸载array类型的子组件就完成了，然后我们来实现设置text children的方法，同样的，在runtime-dom中实现一个hostSetElementText方法，他的作用很简单，就是给元素的textContent赋值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651802135589-cb183469-9f96-48e7-a5f3-84d5c15f1e24.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=65&id=u537b8094&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7171&status=done&style=none&taskId=u022d4d78-c1ca-4b0e-890e-21e5163c612&title=&width=317.6)<br />我们注意到这个方法需要el参数，这个el其实就是父元素，也就是虚拟节点n1和n2的el。<br />我们在patchChildren中分别调用这两个方法就可以实现array->text的流程了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651803031619-d8bb86b3-d8dd-4a66-a81a-bb8ec103aeb2.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=97&id=u9f4d1cf8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=121&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19273&status=done&style=none&taskId=u7e0c621c-ec4d-4164-8690-63a04f57afe&title=&width=403.2)<br />接下来我们实现text->text的流程，这个就比较简单了，直接判断一下n1.children和n2.children是否相等，如果不等直接执行hostSetElementText即可。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651803086293-5c14a8a0-d54a-43fa-b02d-e2fa31bf919f.png#clientId=u8fc36bfd-a858-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=66&id=ude5eafbf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=395&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6823&status=done&style=none&taskId=ueabc4fe6-3b20-4f60-86da-d792b9c7ef9&title=&width=316)<br />接下来我们实现text->array的流程，首先我们要用hostSetElementText把文本设置为空，之后我们需要执行挂载children的操作，也就是我们之前实现的mountChildren方法，直接传入n2的children和el，还有一个parentCompnet参数需要我们从外面的processElement中拿。<br />我们在页面里测试一下这三个场景，发现没有问题，array->array就比较复杂了，这涉及到diff算法，留给之后我们再解决。

<a name="r4n0O"></a>
#### 28.**更新 element 的 children - 双端对比diff 算法 **
这一节我们来实现array -> array的对比，vue中采用了双端对比算法，何为双端对比算法，我们可以看下图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651893314613-357d5300-87b9-4ceb-8110-674080ffc53d.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=529&id=u1d518126&margin=%5Bobject%20Object%5D&name=image.png&originHeight=529&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194810&status=done&style=none&taskId=ud921bb51-87fa-4e69-92da-63bcda748fc&title=&width=944)<br />对于前端的dom，很多时候都是dom的header和footer不变，中间部分节点发生改变，所以我们用双端对比算法找到需要更新的节点范围，效率会更高一些，下面我们就来实现双端对比。

1. **实现从左往右进行比对，假设有如下场景**

a b c -> a b d e<br />我们假设一个下标i，老的节点长度c1.length，新的节点长度c2.length，我们从左往右依次对比节点，如果节点一致，就把i往右移一位并继续对比，否则就退出对比，返回的i就是发生变化范围的左侧下标，代码实现就是：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651893741058-6ac02419-f9c9-42d0-87b1-32a51a2e8666.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=ua4b6b309&margin=%5Bobject%20Object%5D&name=image.png&originHeight=233&originWidth=494&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11796&status=done&style=none&taskId=u1afeb083-7b4d-4514-a160-067471b815a&title=&width=494)<br />isSameVNodeType方法就是判断节点是否相同，目前我们简单实现一下，对比vnode的type和key即可<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651893793548-d0783a10-132a-4fbb-b65c-971b41a904f7.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=98&id=ub6a1602b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=537&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5435&status=done&style=none&taskId=uef6ad5b6-c63a-4013-881e-5128cec53d9&title=&width=537)<br />如果一致我们则用patch方法继续递归对比他们的props和children并i++，否则就退出循环，最后我们得到i<br />运行上面例子我们可以得到i=2，代表从下标2开始，后面的节点发生了改变。

2. **实现从右往左进行对比**

a b c -> d e b c<br />我们这次一样是执行上面的循环，只不过这次下标变成了e1 = c1.length-1，e2 = c2.length - 1，也就是新老节点最后一位的下标，我们和上面一样依次执行比对，如果一致就把e1和e2都往左移一位并继续对比，否则就是退出，并返回e1和e2，代码实现：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651894310728-e612d6e9-9743-428a-9fd5-cf1b7b35b0dd.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=252&id=u9f884ae4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=252&originWidth=559&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12789&status=done&style=none&taskId=ufd0198f4-e20c-40f9-94a1-d79a3a092db&title=&width=559)<br />只想上面的例子我们可以得到i=0，e1=0，e2=1，代表老节点变化范围为0~0，新节点变化范围为0~1

3. **新节点比老节点长**

新节点比老节点长我们分两个场景，场景1：<br />a b -> a b c d<br />在尾部多了新的节点，所以我们要创建新的节点，我们在上面已经拿到了i，e1，e2，在这个场景中我们发现i=2，e1=1，e2=3，在对比过程中，老节点全部被对比完了，所以i > e1，新节点数组中还剩节点没有被对比，所以i<=e2，这些遗留的节点我们认为是新增节点，之后我们执行patch方法第一个参数传入null挂载新增节点即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651895771360-05313815-ed6d-4629-951e-97952374ae0f.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=196&id=u75170a00&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=570&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9035&status=done&style=none&taskId=u63b8576f-3ba7-4b5f-98e0-4c2f0f374bc&title=&width=570)<br />注意这里要循环patch，因为新增的节点可能有很多个。<br />场景2：<br />a b -> c d a b<br />这个场景同样是新增节点，但是是在老节点前面新增的，这次我们的插入操作就不生效了，因为我们插入调用的是runtime-dom中的insert方法，这个方法是无脑的调用parent.append(el)，只会在尾部追加，所以我们要改写一下这个方法，用另外一个insertBefore API来实现，这个api除了接收第一个element参数作为插入内容，还接受一个锚点anchor，会在锚点元素之前插入我们想要插入的内容，如果anchor是null，就和append效果一样，在末尾追加内容。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651907611270-5f96a668-6913-4235-b2de-77a6e0ca71ac.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=113&id=u308dbdfc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=113&originWidth=414&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7173&status=done&style=none&taskId=u4d7cd7f5-cf6c-4022-bf05-3740a9b41a1&title=&width=414)<br />所以现在的问题是要确定这个锚点的位置，不着急，我们首先把调用insert方法的地方都加上anchor参数，影响的范围比较多，我们要更改mountElement，processElement，patch...等方法，总之就是由patch方法一层一层往下传，最后传到mountElement里调用hostInsert的地方。这里注意下初始化render的时候patch anchor传null，初始化不存在往哪个元素前面追加，肯定是append。<br />接下来我们回到patchKeyedChildren，改写一下刚刚patch那部分，我们要找到anchor，也就是要在某一个节点前插入我们新增的节点，我们把这个节点称作锚点节点，我们现在已知i~e2是新增节点的下标范围，那么e2+1就是锚点节点的下标了，这时候我们还需要判断一下如果e2+1大于了c2.length，说明e2对应的节点已经是尾部节点了，此时就不需要锚点了，传null即可，我们之前的代码就该写为：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651908424781-c95015d2-c6b1-4b5e-bc7f-587d7092778b.png#clientId=u49a409c7-c7d7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=267&id=u8388bd2a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=828&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20034&status=done&style=none&taskId=u34181d4e-dab7-4087-9577-652919a4704&title=&width=828)<br />c2[nextPos].el就是锚点dom元素，我们可以打断点在控制台里看到，就是例子里的那个A元素，这样我们的例子就通过了，先往A前面插入一个C，在往A前面插入一个D，结果就是c d a b，不要忘记也测一下之前在后面新增节点的情况。

4. **老节点比新节点长**

a b c d -> a b<br />通过比较可以得到i=2，e1=3，e2=1，可以发现i>e2，这种情况就说明是老的节点比新的节点长，我们拿到多余节点的范围i~e1，执行hostRemove操作删除多余的节点即可，注意remove的参数同样是element<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651977311134-9add3d2e-290e-45f2-9cd4-35c0d18aa60f.png#clientId=u0d3e2f91-4f7f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=114&id=u5088be25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=142&originWidth=478&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9684&status=done&style=none&taskId=uf6e7ad4e-1cc9-401c-92c6-c4df5bf4000&title=&width=382.4)<br />上面是右侧删除的场景，左侧删除的场景：c a b -> a b 我们得到i=0，e1=0，e2=-1，同样符合i>e2的规律，所以逻辑不变，遍历i~e1删除节点即可。

5. **中间对比**

上面两种是理想情况，处理完相同的前置节点和后置节点后总有一组节点被处理完毕，通过新增和删除就能实现比对，但更多的情况是两者长度差不多，只有中间的部分发生了变化，案例：<br />a b c d f g -> a b e c f g<br />![](https://cdn.nlark.com/yuque/0/2022/png/23083224/1651893314613-357d5300-87b9-4ceb-8110-674080ffc53d.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#crop=0&crop=0&crop=1&crop=1&from=url&id=AFfih&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=937&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />我们先来实现老的节点数组中存在但新的不存在的情况，这时候要删掉老的节点。<br />上面我们通过判断i>e1或者i>e2得出新的比老的长，老的比新的长的情况，那么else的情况就是中间对比的情况，基本思路就是遍历老的节点数组，然后再去新的节点数组中查找该元素如果存在，如果存在就进一步对比属性，不存在则删除。这时候我们之前用双端对比算法的优势就体现出来了，我们把需要对比的范围缩小到了i~e1和i~e2，而不用去遍历整个新老节点数组。<br />这里一般来说要实现两层循环，先循环老节点数组，再进去循环新节点数组，但其实我们可以利用key属性去优化，我们可以维护一个map：keyToNewIndexMap，用于存放key和节点在新节点数组中下标的mapping关系，比如我们这个案例就是{'c':3,'e':2}，这样我们就能够通过key直接拿到节点在新节点数组中的下标（位置），顺带也可以判断该节点在新节点数组中是否存在，而且这个get操作的时间复杂度是O(1)，而再遍历一遍新节点数组是O(n)，这样效率就提升了，所以我们先遍历新节点数组，生成keyToNewIndexMap：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652000520071-b18c042b-f263-42d5-acfe-84e8e2a509f7.png#clientId=u98e4ea54-2891-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=128&id=u303627f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=610&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19976&status=done&style=none&taskId=u21f569b2-3c74-4d93-8d24-2d733af87dc&title=&width=488)<br />之后我们遍历老节点数组，如果用户给节点设置了key属性，我们就通过key去keyToNewIndexMap查找，看看是否存在，如果不存在就说明这是一个需要删除的元素。如果用户没有设置key属性，那么我们只能遍历新节点数组，执行之前实现的isSameVNodeType判断他们是不是同样的节点，同时我们要把节点在新节点数组中的下标newIndex记录下来。接下来我们就可以通过newIndex是否为undefined来判断该节点是否存在于新节点数组中，如果不存在，就删除，如果存在，则执行patch方法，继续对比这两个元素的props，children...<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652000942965-961c2017-c768-4cf7-9bfd-3a18d31721ca.png#clientId=u98e4ea54-2891-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=538&id=u0a602e19&margin=%5Bobject%20Object%5D&name=image.png&originHeight=673&originWidth=914&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178989&status=done&style=none&taskId=udf46fb64-2593-4a0f-b3c6-b81799f4920&title=&width=731.2)<br /> 执行一下demo，发现d节点被删除了，并且我们在C节点设置的props id也被修改了，因为我们执行了patch方法对比修改了props。<br />接下来我们可以优化一下，如果场景如下：<br />a b c e d f g -> a b e c f g<br />我们发现，双端对比以后变化的节点 c e d -> e c，新节点数组中存在的节点老的里面都有，那么我们在对比完新节点数组中节点后，老节点数组中剩下的节点就可以直接全部删除了，不需要再执行下面的对比逻辑了。所以我们设置一个常量toBePatched，代表新节点数组中需要对比的节点个数（i~e2），再设置一个变量代表patched已经对比的数量，每次执行到patch的时候patched就+1，如果patched大于等于toBePatched，代表新节点数组中所有元素都已经被比对完了，之后老节点数组中的元素就可以直接删除了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652001611363-8dbe3fd4-12da-4bd7-ab4c-24c3dba83613.png#clientId=u98e4ea54-2891-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=562&id=u82fa59db&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=669&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64323&status=done&style=none&taskId=u4b291da6-ee44-4339-b026-b39c5dd6e73&title=&width=535.2)<br />上面我们实现了删除节点的逻辑，接下来我们实现移动节点，场景如下：<br />a b c d e f g -> a b e c d f g<br />在这个场景中我么发现没有删除或新增节点，只是移动了位置，我们通过双端对比拿到老的变化部分：c d e，新的变化部分：e c d，如果我们暴力求解，就是先把e挪到最前面，再把d插入到c后面，d插入到c后面，这样就移动了三次，但其实我们可以发现cd的顺序是没有变的，我们只需要吧e的位置移动到c前面就可以了，那么我们就可以认为cd是一个稳定的结构，他的顺序相对于老的节点数组是没有变化的，都是递增的，换句话说cde在老的节点数组中顺序是234，在新的中变成了423，23是一个稳定的结构，4是不稳定的，他可以随意插入，但是不论他怎么移动，2都是在3前面的（243,423..），所以我们只要找出这个稳定的结构就可以让我们移动的次数减少，从而减少操作dom带来的性能损耗。<br />找到这个序列我们要用到一个算法：最长递增子序列，这个算法能在我们给定的数组中找到最长递增子序列额下标数组，比如[2,4,3]就返回[0,2]因为第0个和第2个元素组成的数组是最长递增子序列，具体实现这里就不深究了，我们引入一下getSequence。<br />在使用getSequence之前，我们首先得创建一个数组，这个数组的下标是节点在新节点数组变动部分(i~e2)的位置，值是在老节点数组中的位置，如果是0就代表新增的，比如说上面的案例中就是[5,3,4]，我们首先创建这个数组，这里我们指定了数组的长度toBePatched，就是新节点变动部分的长度，这样创建数组性能较好，并且我们首先都赋值0，假设都是老节点不存在的元素：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652087007766-8c896fc3-c90d-4cef-9f42-ecaf808caab2.png#clientId=u9935da77-71a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=u305ca2fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=162&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19796&status=done&style=none&taskId=u5fca9522-0e40-4f76-8815-289c9a6b840&title=&width=670.4)<br />之后我们在判断老节点存在于新节点那部分去赋值：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652087171423-158433e8-eed2-489e-8ccf-163a3d239135.png#clientId=u9935da77-71a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=70&id=uf4cc4531&margin=%5Bobject%20Object%5D&name=image.png&originHeight=87&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9422&status=done&style=none&taskId=uf5410e68-61b2-4b96-b329-411026e8a8b&title=&width=574.4)<br />这样我们就得到了老节点位置组成的数组newIndexToOldIndexMap，我们运用getSequence求得最长递增子序列increasingNewIndexSequence，接下来我们要做的就是遍历新节点数组的变动部分，去子序列中找有没有这个节点，如果不存在说明要移动位置，如果存在则不动，具体实现如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652087800998-e45418e0-22a9-4564-bd1c-46556d7123b7.png#clientId=u9935da77-71a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=ud2d84455&margin=%5Bobject%20Object%5D&name=image.png&originHeight=448&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53489&status=done&style=none&taskId=u09d1fd7f-c8c5-46a7-93e1-b7c5c164403&title=&width=576)<br />这里注意我们使用了反向循环，由后往前遍历c2，因为如果从前往后遍历，我们插入时用insertBefore api需要拿到知道插入到哪个元素前面，后一个元素可能是需要移动或者新增的，这时候c2[nextIndex+1].el有可能是不存在的，我们这里选择反向循环，因为c2的最后一个元素后一个元素一定是存在的（他右侧的节点是双端对比算法去除的右侧未变动节点）。这里我们需要使用j作为子序列的指针，如果当前节点在子序列中，我们就j--，往前对比下一个子序列中的元素，否则就移动元素，我们这里依然要使用hosetInsert执行移动操作，把要移动的节点插入到锚点的位置，所以我们要获取锚点，首先我们要i+s2获取要移动元素的下标，因为i是在c2变动部分中的下标，要加上s2获取在c2中的真实下标，锚点获取的方法和上面类似，先判断一下nextIndex + 1是否小于c2的长度，如果大于的话就是在尾部追加了，锚点就是null，否则就是nextChild后面那个元素c2[nextIndex + 1].el，获取到了锚点我们就调用patch方法进行移动，到这里我们的移动操作就实现了，但还有几个地方可以优化一下：<br />**首先**我们可以判断j，也就是最长递增子序列的长度，如果是0代表新节点数组和旧节点数组是完全相反的顺序，也就是reverse了，那我们就不用判断了，所有元素都要移动。<br />**其次**，我们还可以通过设置一个maxNewIndexSoFar来记录当前最大的newIndex，也就是我们遍历过程中遇到的最大索引值，如果我们在遍历过程中遇到的索引值都呈现递增趋势，说明不需要移动节点，也就是说i~e2整个变动部分除了新增节点和删除节点，剩下的元素都是递增趋势的，所以我们就不需要进行任何移动操作，甚至求最长递增子序列的算法都不用执行，increasingNewIndexSequence直接赋值一个空数组就可以了，并且如果不要移动元素，对比c2和最长递增子序列的过程也可以省略了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652091202123-05c9959b-2b25-4ec8-9b29-fbeb8bf8a31f.png#clientId=u9935da77-71a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=115&id=uc2df4779&margin=%5Bobject%20Object%5D&name=image.png&originHeight=144&originWidth=615&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11834&status=done&style=none&taskId=ud81a2900-e026-4db9-8dfa-d7e30a6cc55&title=&width=492)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652091121252-8f011e76-b2b4-4263-bb11-e2779dca3348.png#clientId=u9935da77-71a7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=418&id=ucc40c32e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65279&status=done&style=none&taskId=u50c47ea0-0fd3-4bf6-b7d2-6910e6974c8&title=&width=610.4)<br />最后，我们来实现新增节点的情况，我们上面知道，生成newIndexToOldIndexMap的时候我们默认每一项都是0，代表是新增的节点，所以我们在遍历c2的时候判断一下，如果newIndexToOldIndexMap[i]是0，就执行patch方法新增节点，并且新增的位置也是在锚点之前。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652148223156-5c0e7f00-e840-47e6-94dd-fe5f7ae7ad06.png#clientId=u2c21e8db-b49b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=65&id=u81db4a30&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12423&status=done&style=none&taskId=ub8740717-67ab-4740-ac26-f17f3db07cc&title=&width=491.2)<br />至此vue3中使用的diff算法就实现完了，总结一下：<br />diff算法先进行预处理，处理新旧子节点中相同的前置节点和后置节点，当处理完毕以后，如果无法简单地通过挂载新节点或卸载不存在的节点来完成更新，则需要根据节点的索引关系，构造出一个最长递增子序列，最长递增子序列所指向的节点即为不需要移动的节点。
<a name="Di1F1"></a>
#### 29.实现组件更新功能
之前我们实现了element的更新逻辑，现在我们来实现组件的更新，首先看demo：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652249975530-4b8548cd-9939-4111-89e3-aed68f3c97df.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=688&id=u6ae8190f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=860&originWidth=726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75252&status=done&style=none&taskId=u64f588ba-5aca-4bd4-9c64-0505846491f&title=&width=580.8)<br />首先我们实现了一个App组件，他里面使用了一个Child组件并传入了一个props：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652250032493-ccab54a2-6445-4465-aa43-26cae186ae7a.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=ueb18d3fe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=253&originWidth=860&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23943&status=done&style=none&taskId=u6d672493-503d-4f6c-a57a-8a75bfeb518&title=&width=688)<br />App中点击按钮会修改msg，所以Child组件显示的文本应当发生变化，我们可以看到Child中通过this.$props获取了组件props，这个我们先实现一下，很简单，在componentPublicInstance.ts中新增一个$props属性即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652250160827-d83def41-0231-4c0f-a7a2-fc6e0e4b1dc4.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=90&id=u611b3ce0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=348&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9586&status=done&style=none&taskId=udc4e15b8-85cc-42c9-a58f-f37f16fa6e5&title=&width=278.4)<br />接下来我们实现更新操作，在之前更新element流程搭建中我们知道，要实现更新其实就是在执行一遍effect.run，之前是我们在render方法中使用了响应式对象，当他改变了之后触发effect.run实现的，但是现在我们在Child子组件里并没有响应式对象，仅仅使用了props，所以我们要在父组件发生变化时手动去调用effect.run，并且更新Child组件instance上的props属性，这样Child拿到的this.$props.msg才会变化。<br />之前我们在实现响应式的时候知道，effect返回了一个runner，他就是effct.run，所以我们调用这个runner方法就可以了，我们可以把runner方法赋值给instance.update，在组件更新的时候就可以instance.update()来实现更新了。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652250855010-5610a7c9-ce2a-4b81-943b-611d4d56bc9d.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=41&id=u85f74860&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=474&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6948&status=done&style=none&taskId=u332e022e-75af-4b28-bf88-f22ab688a92&title=&width=379.2)<br />之后我们修改processComponent方法，如果n1不为null，就执行updateComponent方法而不是mount。当父组件App点击按钮更新msg后，会进入到他的update流程，进而进入patch subTree的流程，由于App的根节点是一个div，所以会进入patchElement -> patchChildren流程，在patchChildren中，当对比到Child组件时会发现type和key都一样，进而又进入patch Child组件的流程中，由于Child是组件类型，所以会进到我们写的updateComponent方法中，这时候我们拿到了Child组件更新前和更新后的两个vnode：n1,n2，这时候我们需要调用instance.update()来触发更新，但是instance目前是没有的，我们可以预先在mountCompont的时候把instance挂载到vnode上：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652251618499-50a61347-5746-42f5-8333-51a94b7d806e.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=43&id=u4e37c543&margin=%5Bobject%20Object%5D&name=image.png&originHeight=54&originWidth=836&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11821&status=done&style=none&taskId=ua97b0b80-3666-4745-aebd-62fe8183732&title=&width=668.8)<br />这样我们通过n1.component就可以拿到instance了，这里要注意，我们只在挂载的时候赋值了vnode.component，此时只有n1是有的，我们需要赋值给n2，不然下一次更新拿到的n1上面就没要component属性了。然后我们要把新的vnode也就是n2，挂载到instance的next属性上，因为我们要在runner中更新instance.props来实现组件内容更新，而instance上目前挂载的vnode是创建instance时候赋值的，肯定是过时的，所以我们要把n2赋值给instance.next，之后我们改写一下effect中的更新逻辑：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652252811263-998950d4-212a-4633-a23e-5716ef21af3b.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=257&id=ud68b60c0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39863&status=done&style=none&taskId=u7ce20275-58f3-4108-b89b-388fd721f1d&title=&width=634.4)<br />首先从instance中拿到next和vnode，一个是新的vnode一个是旧的，如果next存在说明我们要更新instance的props，此时先next.el=vnode.el，道理和上面赋值n2.component一样，vnode.el只是在mount的时候由subTree.el赋值，next.el肯定是没有的，所以要赋值上。之后我们就可以执行updateComponentPreRender来更新instance的props了：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652253338258-d671ed70-65d8-4648-ac72-60ed513d17e5.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=136&id=ue40311ea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=170&originWidth=703&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21433&status=done&style=none&taskId=ud64d4c6b-1503-49ec-937b-27e47746625&title=&width=562.4)<br />直接把nextVnode上的props赋值给instance.props即可，同时我们要重置instance上的vnode和next，此时老的vnode变成了next，新的vnode就是null了。<br />最后我们有个地方优化一下，我们在App.js中还实现了一个按钮，他更新了App中的count，这个count和Child组件是没有关系的，但是由于我们只要更新了父组件，子组件都会去执行patch，从而进入到updateComponent中进行更新，这其实是没必要的，我们只有在子组件的props发生变化才需要更新他。所以我们实现一个方法_shouldUpdateComponent：_<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652253648278-f03314d4-729c-41e9-a91d-7001acaa4531.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u128982bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=251&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29765&status=done&style=none&taskId=u6af3fda6-bab2-4c73-9cb8-19c401ad4b3&title=&width=504)<br />他会去对比新老vnode的props，如果不一样返回true。这样我们在调用instance.update前判断一下，如果props发生课变化再执行：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652253903089-9b7c4d6c-1899-440e-974e-599b49bff685.png#clientId=u2f599b63-6633-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=251&id=uaa8a4d89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=314&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31638&status=done&style=none&taskId=u791f7b70-ebb5-474f-be1d-53e29530ed7&title=&width=597.6)<br />这里我们注意，如果props没有变化我们不能什么也不干，n2.el=n1.el，instance.vnode=n2这些在更新中做的拷贝属性的操作也是要做的，否则再下次更新这些属性拿到的就都是null了。现在观察demo页面，我们在update这里打上断点，可以发现如果更新的是count就不会进来，这样我们就避免了多余的更新操作了。
<a name="sUoZB"></a>
#### 30.实现nextTick
之前我们直线了组件,element的更新逻辑，现在我们写一个demo：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652410259583-e5176e57-7023-4b87-bbda-046fde512a35.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=421&id=u3212ccad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=526&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46099&status=done&style=none&taskId=u1922a595-5009-41d0-b895-ee5c0eedefa&title=&width=656)<br />点击按钮触发一个onClick事件，这个事件里会循环修改响应式对象count100次，之后我们可以在renderer中patch或patchProps那里加上log，会发现我们执行页面渲染的代码也执行了100次，这其实是没必要的，我们的页面只需要渲染一次，就是count由0变为99，不需要执行100次渲染，所以我们希望有一个机制，能够在所有的更新操作完成后再执行一次渲染。<br />怎么做到呢，我们想到了js执行机制里的微任务，具体细节这里就不再介绍，简单来说就是当js执行代码时遇到Promise这样的代码，不会立马执行Promise.then中的回调方法，而是将其推入一个微任务队列，在所有同步代码都执行完毕以后再去微任务队列中安装按照先进先出的原则执行其中的微任务，所以这里我们可以将所有的更新逻辑放入一个队列queue中，每次响应式对象变化我们不执行instance.update，而是将其作为一个job推入这个queue，之后在所有响应式对象变化这些同步代码都执行完之后，我们再创建一个微任务，去遍历执行queue中的job，也就是instance.update逻辑从而更新页面。知道了思路我们来实现代码，我们现在是将页面更新逻辑包裹在了effect里了，所以每次响应式对象变化都会执行页面更新，为了避免页面更新我们给effect方法传入第二个参数scheduler，在scheduler里执行一个queueJobs方法，把当前instance.update当做job传进去，这样除了第一次初始化，之后每次响应式对象更新就只会执行我们的queueJobs方法而不是更新逻辑了。<br />queueJobs实现如下，将job去重并push到一个队列queue中：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652412020412-107622e3-6bfb-47d4-9d72-5bdd325aa0a1.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=116&id=u11ee9198&margin=%5Bobject%20Object%5D&name=image.png&originHeight=145&originWidth=368&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11264&status=done&style=none&taskId=u8695e676-7d10-4a0c-a971-de9bc1682e0&title=&width=294.4)<br />之后执行一个queueFlush方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652412695176-c148d16c-8102-45a4-a3d5-af289a756dc8.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=uaf33463d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40313&status=done&style=none&taskId=uf4f264be-7781-4d43-9490-d6190855385&title=&width=316.8)<br />queueFlush方法用Promise.resolve()创建了一个微任务，我们在then中实现遍历执行job的操作，这时候我们再去控制台看下log，可以发现虽然我们同步代码里循环修改响应式对象执行了100次，但是update->patch这部分只执行了一次。<br />接下来我们可以优化一下代码，我们注意到我们queueJobs，queueFlush方法还是会执行100次，也就会创建100次Promise对象，这其实是没必要的，我们只需要创建一个Promise微任务即可，所以我们来实现一个flag，或者可以说是一个锁isFlushPending，默认为false代表微任务还没有被创建，创建完之后就改为true，之后执行queueFlush的时候如果检测到isFlushPending位true就代表微任务已被创建，无需再创建了，最后我们要在微任务执行完把状态重置为false。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652413210072-b9b30b49-c4a5-4ee7-95b9-3d7fd66cd103.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=367&id=ubc72fcff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=459&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109824&status=done&style=none&taskId=uf5af7ba7-9aef-4d8e-9847-3eeabbfb3ef&title=&width=345.6)<br />去控制台观察下重构完效果，发现没有问题。<br />到这里我们了解了vue异步更新视图的逻辑，我们知道我们在更新完响应式对象之后视图并不会立刻更新，也就是说如果我们在onClick事件里获取一下组件instance.el，可以发现其中的count文本显示的还是1，如果我们想在这里拿到更新完成以后的视图该怎么办，vue官方提供了一个nextTick方法可以让我们在传递的回调函数中，或者await nextTick返回的Promise，拿到最新的视图：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652413729769-f3658052-91cc-4ec8-9194-f2e6a85a9131.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=447&id=u1d106db0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=967&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51723&status=done&style=none&taskId=u6de11116-81f8-4d32-9422-a5deb17d97e&title=&width=773.6)<br />现在我们就来实现一下nextTick，要实现nextTick，其实就是希望等待更新视图的操作完成，我们已知更新视图的操作在是放在微任务里做的，要获取上一个微任务的结果，我们只需要往微任务队列里再推入一个微任务即可，根据先进先出的原则，我们在下一个微任务中可以获取到上一个微任务的执行结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652414312032-c11e4a0e-4bd4-4426-8d20-1e1189af9863.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=214&id=u48331521&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=332&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18002&status=done&style=none&taskId=ua2c289ca-bcb9-47f3-970b-d285cfb5ac2&title=&width=265.6)<br />这个例子打印的结果是 0 1 2 ，验证了微任务的执行顺序。<br />这样我们就可以实现nextTick了，再创建一个微任务，把要执行的方法传到then中，如果用户没有传参，就返回一个promise让用户去await，这样之后的代码一样是在下一个微任务中执行，也就可以获取到上一个微任务（视图更新）完成之后的结果了。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652414373145-d8d6935b-c96f-4741-a933-598cbc8d35bf.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=119&id=ub52bf665&margin=%5Bobject%20Object%5D&name=image.png&originHeight=149&originWidth=681&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13698&status=done&style=none&taskId=u627c04b6-f4e3-48dd-98bd-eeb31f7419d&title=&width=544.8)<br />这里我们继续优化一下，首先nextTick本质就是创建一个Promise，我们在queueFlush中也是创建Promise，可以复用nextTick：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652414639537-9f1c44e1-6199-48bf-bd78-bd140b3a7cbf.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=152&id=udc0db329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=190&originWidth=696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19451&status=done&style=none&taskId=u3c3f8051-6220-4263-8edd-bcfdd000cab&title=&width=556.8)<br />并且nextTick中每次执行都会创建一个Promise，其实也是没必要的，我们复用一个即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652414728416-6a0ab860-d25a-45f5-81b5-9580567335ff.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=25&id=u5d1adae4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=31&originWidth=275&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3724&status=done&style=none&taskId=u68f12054-b0fd-4820-a13d-1aba6ec9b82&title=&width=220)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652414734472-5373df75-5124-420d-8ebd-0759313af73e.png#clientId=u6fd92415-f969-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=77&id=u29e411d8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=687&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10207&status=done&style=none&taskId=u286a2e37-ec92-4ea2-abc8-6c448c5160f&title=&width=549.6)
<a name="tvhfr"></a>
#### 31.编译模块概述
这一节我们进入编译模块的学习，编译就是一段代码在执行前会经历**分词-->解析-->代码**生成这三个步骤。<br />分词：这个过程会把代码字符串分解成有意义的代码块，这些代码块统称为词法单元，比如let a = 1这段代码会被分为let, a , = , 1。<br />解析：这个过程会把词法单元转换为一个程序语法结构的树，这个数被称为抽象语法树（AST），可以理解为就是一个大的树形结构的json对象。<br />代码生成：把AST转换为可执行代码的过程<br />有了编译，我们就可以对代码进行许多预处理操作，比如babel拿到我们的代码先转换为AST，再根据一定的规则进行批量替换，最后再生成新的代码，使得我们的代码能够兼容低版本浏览器。<br />在vue3这里我们特指将template模板转换为render函数这个过程为编译，我们在vue-next-template-explorer可以观察到编译前的template和编译后的render函数：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652684621306-4f9e92c4-f681-4b8c-94b9-3425cf71911b.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=62&id=ue8e14a02&margin=%5Bobject%20Object%5D&name=image.png&originHeight=77&originWidth=453&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3609&status=done&style=none&taskId=u5336d785-efca-4f5a-84b1-f2d133edd82&title=&width=362.4)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652684645529-562d3739-f9d1-4167-83cf-ddc1e6126b1f.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=150&id=ubc788c1a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19816&status=done&style=none&taskId=uf7ed618d-0158-4a55-99d7-1b014ac785f&title=&width=820)<br />这就是我们编译模块需要实现的内容，首先我们来实现分词和解析，把代码转换为AST，之后再实现AST生成render函数。
<a name="BqgaU"></a>
#### 32.实现解析插值功能
我们首先实现解析插值的功能，也就是{{message}}转换为我们想要的AST，首先我们写个测试：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652685270936-af4919af-d9b4-4107-a64b-e2e82036ecbe.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=295&id=u24bc1d26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42237&status=done&style=none&taskId=u32ce22d1-526b-41c7-8830-6446abf4c6a&title=&width=446.4)<br />我们输入一段文本'{{message}}'，经过baseParse方法转换，最终生成一个ast树形结构，他下面有一个children属性，第一个值为一个对象，这个对象描述了代码类型是插值，并且插值的内容是一个简单表达式，内容为'message'。接下来我们就来着手实现baseParse方法，我们新建一个compiler-core目录，在下面的src中新建parse.ts，这个方法返回一个对象，对象的内容就是AST。<br />接着我们创建一个上下文context，这个context是一个对象，把我们传入的代码字符串放在这个对象中：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652686357956-804773fb-655e-41d7-9c6f-fbcc556aa8f3.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u99205584&margin=%5Bobject%20Object%5D&name=image.png&originHeight=127&originWidth=467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9292&status=done&style=none&taskId=ua5f9a996-94b0-4dc7-86ba-97186b595e5&title=&width=373.6)<br />之后我们进一步拆解AST对象，AST对象是一个树形结构，所以他会有一个最外层的root节点，我们创建一个方法接收children，返回root节点：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652686442875-f92198af-6914-4a41-b8ce-dab2146b4ebb.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=u1bb5fbd0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7342&status=done&style=none&taskId=u37f73b8d-db98-49a2-b798-9c54f06f4ba&title=&width=415.2)<br />有了root，我们就要实现children，我们写一个方法parseChildren根据我们刚刚创建的context来生成children：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652686547803-7ae14751-31e3-4aee-821b-57d0b94ac36c.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=166&id=u0e31a2b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=469&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20601&status=done&style=none&taskId=ud63d04f0-a0af-432b-9c92-367b738a1c6&title=&width=375.2)<br />具体就是创建一个nodes数组，这节我们只实现解析插值，就判断一下如果文本是{{开头，就进入parseInterpolation转换插值的方法，返回一个AST对象node并push到nodes里，所以接下来我们实现parseInterpolation这个方法即可。<br />我们注意到，我们需要返回的AST中只有content的内容是需要填的，也就是说我们要从{{message}}中解析拿到中间message这几个字符，要怎么拿到呢，其实利用js中字符串的slice分割字符串的方法就能拿到。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652686928313-d28898d5-956f-4af2-ae1d-e9d96dd2eb49.png#clientId=u5d317407-1ca7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=506&id=ubd5d7845&margin=%5Bobject%20Object%5D&name=image.png&originHeight=632&originWidth=757&originalType=binary&ratio=1&rotation=0&showTitle=false&size=79273&status=done&style=none&taskId=u0ff0da97-570a-4f11-81e4-d2b9ae30fa5&title=&width=605.6)<br />简单介绍下上面的代码，我们定义好前后分隔符：'{{'和'}}'，首先根据}}拿到闭合位置的索引，因为插值一定是以{{开头的所以我们可以往前推进两个字符，也就是直接删除{{，之后我们用闭合位置的索引-2，也就是{{的长度，这样就可以得到content的长度，之后我们用slice方法截取得到content的内容并去除首尾部空格，最后我们吧content的内容放到AST中即可。<br />我们运行单元测试，可以看到结果是正确地，这样我们解析插值就实现了。
<a name="uq04p"></a>
#### 33.实现解析element标签
这一节我们实现解析<div></div>这样的element标签，首先写个测试：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652759890891-675c27b5-a097-44bb-b82a-ba2c17e1d861.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=u8bcf5d4a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=527&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25521&status=done&style=none&taskId=u62bf913a-a130-4515-9135-a6df46be64c&title=&width=421.6)<br />我们输入一段<div></div>标签，需要解析方法返回一个AST对象，对象的类型是element，tag值是div。<br />接下来我们来实现对应的parse，我们在上一节实现了对插值内容的解析，当时我们判断一段字符串是不是插值用了startsWith('{{')，这次我们判断是不是element可以这样，先判断该文本是不是以'<'开头，并且下一个字符必须是字母，这样我们可以认为他是一个html标签：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652760190387-c32a4126-15fe-4065-92e2-5a79463d6bf3.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=95&id=u60dc9015&margin=%5Bobject%20Object%5D&name=image.png&originHeight=119&originWidth=517&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13177&status=done&style=none&taskId=u7b922b0d-feca-40ed-a0dd-0a063306b16&title=&width=413.6)<br />接下来我们实现parseElement，首先我们要写个正则来获取到<div>中的div这几个字符，并且我们要保证处理完以后把<div></div>这几个字符都删掉，也就是向前推进。所以这个正则是这样的：/^<\/?([a-z]*)/i，首先是以<开头，并且<后面有可能有/，闭合标签我们也要匹配到，之后的话就是任意位数的字母，并且我们用()包起来，这样我们下面用exec函数匹配的时候就能拿到()中匹配的内容，也就是tag内容div，拿到了tag，我们要向前推进，把匹配到的内容删掉，然后构造AST对象并返回即可，这里要注意，如果匹配到的是闭合标签</div>，就不用返回AST对象了，所以我们用一个tagType类型参数做区分：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652760694895-f499888f-9228-4fd5-a2c9-24094bb2eecf.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=130&id=u97ba3f7e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=512&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18701&status=done&style=none&taskId=u2baf0a81-7270-4bbd-96ed-87517f7e4d8&title=&width=409.6)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652760681702-1e622d84-4d28-4136-8867-7077fc82a390.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=290&id=u2b981fe7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46403&status=done&style=none&taskId=u7e3dfd69-1742-413a-bb18-8ea5936638e&title=&width=508)<br />先执行一次开始匹配，再执行一次闭合标签匹配，闭合标签匹配就不返回AST对象，但是要执行推进操作删掉标签的内容。这样我们匹配element标签就实现完了，单测可以看到是正常通过的。
<a name="wTlrT"></a>
#### 34.实现解析text功能
这次我们来实现解析text，还是先写测试：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652770367453-abe9a0d6-ab87-4fc7-8fd2-0751a5c4b8ba.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=182&id=ud0f62ef3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=531&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25915&status=done&style=none&taskId=u9662985d-da16-40a6-b740-bfa1797035f&title=&width=424.8)<br />传入一段文本，最终返回一个类型为TEXT的AST对象，对象的content就是我们传入的文本内容。<br />下面我们来实现，首先我们要知道用户传入的是一段文本，怎么判断呢，上面我们判断了传入的文本是插值还是标签，那么剩下的情况我们就可以认为是一段文本：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652770490547-94c5f8e6-df2d-4a59-b735-396d1a83622d.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=ucb66e891&margin=%5Bobject%20Object%5D&name=image.png&originHeight=407&originWidth=604&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40539&status=done&style=none&taskId=u6aa53ccd-3d99-471b-8a72-9941b28a13d&title=&width=483.2)<br />如上图，如果node此时为undefined代表文本不是插值也不是标签，就进入parseText方法，这个方法很简单，就是直接返回一个AST对象，对象的内容就是context.source的内容，并且我们推进一下把这段文本内容删掉即可。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652770724539-a1404dd0-7ad6-41ca-a818-3a2026f3a3e2.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=ueba54673&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=64502&status=done&style=none&taskId=u9190d0c1-c0f3-45d4-8846-23afa320ce1&title=&width=510.4)<br />这样我们处理text的功能其实就处理完了，观察单测运行结果可以发现一切ok，接下来我们优化一下代码，我们可以看到，获取content和推进这一块的代码我们在处理插值的时候也有过类似的：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652771370628-afd5c511-aa00-407f-9080-075ee1f7a6c9.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=98&id=ud6c8a799&margin=%5Bobject%20Object%5D&name=image.png&originHeight=123&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20572&status=done&style=none&taskId=u19522478-c50e-4277-83b7-46fcd977a7e&title=&width=502.4)<br />所以我们可以封装一个通用的方法parseTextData，传入context和要截取的长度length，截取出这段内容并推进（删除）相应的长度：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652771436606-caa79c54-de60-42cb-a487-6ca30f47ecc4.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u09ef38f6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=127&originWidth=467&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15711&status=done&style=none&taskId=u9d0d6672-9580-4744-a011-253bd0da7fd&title=&width=373.6)<br />这样我们就可以优化parseText和parseInterpolation方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652771634687-0d0e1c41-48a9-468d-822f-3fb3066a33a3.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=132&id=u785cb87e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=165&originWidth=637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16297&status=done&style=none&taskId=ub8ed8d94-40b3-44d0-9a85-73f084a0735&title=&width=509.6)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652771644260-19cd10d3-c6ba-4ee0-9c06-006e70c173b9.png#clientId=u067636b3-e884-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=96&id=u132bb0c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=120&originWidth=591&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18061&status=done&style=none&taskId=ud6a1cd38-78a7-4339-a80c-11c38628448&title=&width=472.8)<br />优化完以后别忘了跑一下所有单测，看结果是否正常。
<a name="W2Qxj"></a>
#### 35.实现三者联合类型
上面我们分别实现了对插值，标签，文本的AST解析，接下来我们将这三者联合起来实现一个综合案例：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652796644134-52eb2d48-ac4f-4cf6-bb15-f231fa12c745.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=430&id=uce356841&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28046&status=done&style=none&taskId=u7fa5917a-1cd3-48be-ab1b-8822b6d0bdf&title=&width=617)<br />我们实现一个<div>hi,{{message}}</div>的案例解析，最终需要返回一个树形结构的AST对象，首先最外层是一个element，标签名为div，他下面有一个children属性，里面有两个元素：一个text，一个插值表达式。<br />首先element类型由于我们之前实现过了，但是之前是没有children属性的，只解析开头标签和闭合标签，所以我们要在解析开头标签和闭合标签之间加上解析子节点的方法，这个方法其实就是我们之前已经实现了的parseChildren方法，这个方法是对各种类型的内容统一处理的方法，因为<div>下面有可能还有子标签，文本，插值等等，所以我们用这个通用方法进行子节点处理：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652797015486-33e2719c-f9d0-44a9-9751-9bb12eee91f0.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=u5764c09a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22302&status=done&style=none&taskId=u774b2838-df98-4e00-a8cc-754e797c783&title=&width=654)<br />进入到子节点处理，由于我们<div>这个标签内容已经处理完毕，会向前推进，此时我们的context.source内容就是hi,{{message}}</div>，这时候第一个字符是text类型的文本，会进入parseText方法，但是我们之前实现的parseText方法是直接从头读取到尾当做文本内容的，而这里我们后面还有插值内容{{message}}，肯定是不行的，我们这里要读取到{{时停止，将之前的内容当做text类型，所以我们修改下parseText方法：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652797407957-8f31f8e5-e441-4c7a-a88a-031f6c3c2dee.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u261fccb1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20826&status=done&style=none&taskId=ub13709c9-deed-4d3b-9b3c-d31ce6b67db&title=&width=529)<br />首先查找{{，如果找到，就截取之前的内容作为text内容，这样我们读取到的text就是hi,后面的插值类型文本不会被读取到，因为我们parseChildren方法只会执行一次node的判断赋值，所以我们读取到这里就停止了，这肯定是不行的，我们要继续读取内容，直到文本被读取完了或者读取到父级element的闭合标签</div>时停止，所以我们要修改parseChildren，改为循环读取context.source并执行判断和node赋值，并且我们要写一个isEnd方法用来判断循环是否需要停止：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652797794843-79d249e3-5a2d-4f5f-8e86-41c75069fc9a.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=165&id=u942d31f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=165&originWidth=455&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8689&status=done&style=none&taskId=u08c622f5-a894-40e7-a07e-359f56dac85&title=&width=455)<br />这里有两个判断条件：1.如果context.source是以</div>开头，代表读取到了闭合标签，停止。2.context.source没有内容了，也需要停止。但是这里我们是写死</div>的，实际标签内容是由父element节点的tag内容决定的，所以我们要在parseElement里把tag传进来：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652798100750-35256e2f-c1ea-4b03-b397-f46b051a0c1a.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=34&id=u1f374ce3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=34&originWidth=519&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4126&status=done&style=none&taskId=u82a96471-7bd2-4e7c-a658-35eb71ddece&title=&width=519)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652798121492-5ac454b5-a6da-49c1-bef7-84b4433d9049.png#clientId=uf45eeb17-9923-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=208&id=u750b748a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=612&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15715&status=done&style=none&taskId=u7878a05c-58c0-4e8b-956f-83f1700fa10&title=&width=612)<br />这样标签的内容就可以改为动态的parentTag，我们现在虽已替换标签为div,p,h1...都是可以的，这里还需要修改一个地方，我们在最开始createRoot的时候执行了一次parseChildren，这里的tag我们就传一个空字符串，并且在isEnd里，我们检测到如果parentTag是空字符串就没必要判断parentTag了，直接进入下一步判断context.source是否为空即可。运行单测，发现是ok的，这样我们就实现了最基本的三个标签联合类型生成AST对象的操作。<br />接下来我们实现两个边缘case，第一个我们在div中再嵌套一个p标签，p标签中有一段text文本：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652858634792-e38a4724-f64e-469c-b5ce-a59d8372674c.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=480&id=u2fdc2cac&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=753&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49158&status=done&style=none&taskId=ubb57dba1-0891-406a-9cbf-46691395bf3&title=&width=602.4)<br />我们运行测试会发现不通过了，因为我们之前parseText的时候只考虑了读取到{{才停止的情况，遇到闭合标签</p>并不会停止读取，所以我们要修改parseText方法，添加读取到闭合标签时停止的逻辑，当读取到{{或</时停止，并且获取位置，取位置靠前的作为endIndex进行截取，之前的内容才是text：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652859119621-f0f07641-786d-49a4-b52f-77ba34e7813b.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=287&id=uae591655&margin=%5Bobject%20Object%5D&name=image.png&originHeight=359&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38352&status=done&style=none&taskId=u37305679-17d6-4bae-b217-df99183d3d0&title=&width=568.8)<br />第二个边缘case是这样的：<div><span></div>，这里的span标签没有闭合，这里我们希望抛出一个错误，告诉用户span标签没有闭合：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652859431699-e878894e-febe-4059-b2eb-b44e3afbe410.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u31184003&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18181&status=done&style=none&taskId=u87b61d01-ca39-406a-a89c-c8189c8691a&title=&width=508)<br />这次我们的单测直接死循环了，原因是我们在isEnd函数中判断span标签的子节点是否读取完毕时，拿到的parentTag是span，但是此时context.source后面的内容是</div>，两者并不匹配，所以isEnd一直返回false，循环就永远结束不了了。为了解决这个问题，我们需要改变isEnd的逻辑，我们不能判断context.source是否是parentTag的闭合标签，因为有可能parentTag是不闭合的：而应当维护一个栈，每次处理element标签的时候，把element推入到栈中，判断isEnd的时候如果context.source下一段内容是</开头的，也就是一个闭合标签，就去栈中从顶向下寻找（而不是只找最顶上的）是否有标签名和这个闭合标签匹配，如果有的话就认为标签闭合，子节点读取完毕了，退出循环。<br />所以我们首先要实现一个栈ancestors用来存放已经读取的所有开始标签，默认为空数组：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652860632212-fc2c22fc-3040-46e5-8869-4375d1312bbc.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=74&id=u40fa89c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=92&originWidth=518&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15921&status=done&style=none&taskId=uad92e1dd-85b6-46ba-944d-7ae0ff63730&title=&width=414.4)<br />在每次parseElement的时候，给栈中推入一个element，并且在处理完子节点后弹出这个element：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652860703133-4e198afe-a626-4342-95ab-ba23ba75341b.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=uf2a72eef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17356&status=done&style=none&taskId=u91728598-0ee3-4d55-b979-1f99e38cbc0&title=&width=442.4)<br />这样我们把ancestors传到isEnd方法中，在那里去从顶向下循环查找是否有element标签能形成闭合：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652860747946-21319e5e-0b5d-4f61-be1b-7616b90d9b1e.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=256&id=ue689e01a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=777&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32814&status=done&style=none&taskId=u4c2d495f-4795-474e-ac8e-dcbfa01385c&title=&width=621.6)<br />判断方法我们提取到一个函数中，其实就是截取source再和tag名称进行对比：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652860852550-747e7c73-01fe-42e9-896e-cecc829c36ea.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=94&id=ua0ed865f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=118&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17537&status=done&style=none&taskId=u3a705d2c-203d-44b3-a436-80998b2f180&title=&width=734.4)<br />此外，还有一个地方需要修改，在parseElement中，我们读取完子节点会再次进行parseTag操作删除闭合标签并推进，如果<span>标签没有闭合标签，他也会继续往前推荐并删除掉后面的</div>闭合标签，这是不正确的，我们需要加一个判断，只有context.source后面的闭合标签和当前的开始标签匹配上，才进行推进，否则就抛出标签未闭合的报错：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652861124301-13b241bc-2429-4c39-b445-2e61b3d693b1.png#clientId=u44219121-53a1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=u54fd950c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=651&originalType=binary&ratio=1&rotation=0&showTitle=false&size=60473&status=done&style=none&taskId=u6efcb026-3eae-47de-82b8-2e23e79dce0&title=&width=520.8)<br />此时我们运行单测，可以看到错误被正确地抛出了，这样我们两个边缘case也实现好了。
<a name="qcj4q"></a>
#### 36.parse的实现原理&有限状态机
所谓有限状态机，就是读取一组输入，根据输入更改为不同的状态：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652931424243-ebfd4d6f-0666-4adf-a511-9418545d1d0b.png#clientId=uab746dd3-180f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=370&id=ufcbb22ea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=462&originWidth=825&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42738&status=done&style=none&taskId=u860d5151-a1e7-40da-aa60-696639c3ccc&title=&width=660)<br />如上图所示，state1输入x变为了state2，输入y则变为state3，我们日常中写的if-else，switch语句都可以看作有限状态机，我们上面实现的parse转换AST树其实也可以看作是有限状态机模式：我们先处理一段文本，他就可以看做是一个初始状态，如果这段文本是以{{开头我们就认为是一段插值，此时状态就变为插值，如果文本遇到}}我们就认为插值结束了，此时回到初始状态，继续往下读取，如果下一段文本是<[a-z]开头，我们就认为是一个element标签，此时状态就变为parseElement...通过while依次往复，最终读取完全部的文本：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652932237212-4a290c3c-479f-4ccb-b58f-5abbaf5ede96.png#clientId=uab746dd3-180f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=697&id=u5bc8a057&margin=%5Bobject%20Object%5D&name=image.png&originHeight=871&originWidth=1303&originalType=binary&ratio=1&rotation=0&showTitle=false&size=253603&status=done&style=none&taskId=ua36a46da-42f7-4ef5-aebe-a17c4896180&title=&width=1042.4)<br />我们可以利用有限状态机来实现正则表达式，因为正则表达式底层的解析器就是用有限状态机来实现的。我们假设来实现一个正则表达式/abc/的test方法，这个方法对包含abc的字符串返回true，否则返回false，我们来利用有限状态机来实现这个方法：首先我们定义三个函数waitForA，waitForB，waitForC，代表三个状态机，初始状态为waitForA，他们接收一个字符char，如果字符分别为a,b,c就改变一下状态，比如waitForA方法如果读取到的字符是a就return waitForB，否则就回到出事状态waitForA，并且我们还要定义一个最终状态end方法，如果此时状态机为waitForC并且读取到的字符为c，说明完全匹配到了字符串abc，此时状态就为end：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652967133473-b0da53d4-3c96-4ca4-a225-a0fc6559a7df.png#clientId=u330f0a24-6a17-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=507&id=u9653f4a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=507&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22600&status=done&style=none&taskId=u5ea27ae1-b564-4e55-8965-01c3272accb&title=&width=438)<br />接下来我们写一个循环，依次读取传入参数string的每一个字符，并且定义一个当前状态currentState，初始值为waitForA：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652967423679-e50cdaf0-1511-4eef-8f90-68d7ba53b317.png#clientId=u330f0a24-6a17-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u41337f36&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=450&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11443&status=done&style=none&taskId=u3fc9b3fb-7f61-4a9d-9cc2-654c6f7a7ea&title=&width=450)<br />当前状态是三个状态机函数中意的一种，函数的返回值就是下一个状态，把下一个状态赋值给currentState继续执行循环，如果下一个状态是end就代表匹配到了abc，退出循环return true，否则就return false，这样我们就实现了一个基本的正则匹配字符串abc的方法。<br />接下来我们稍微优化一下这个方法，如果我们需要返回匹配到的abc在当前字符串的位置索引，并且能够执行全局匹配该怎么写。要执行全局匹配我们就不能在状态机为end时return true了，所以我们要把return先干掉，然后要返回index，我们先初始化两个边路startIndex,endIndex，当我们在状态机为waitForA且读取到的字符为a，也就是状态快要变成waitForB时记录下startIndex，在状态快要变为end时记录下endIndex，这个startIndex和endIndex就是我们当前循环的索引i，但是目前我们的遍历i作用域是在循环内部的，所以我们要提取到最外面：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652968396983-58b09201-b845-407c-9a29-55160054cd21.png#clientId=u330f0a24-6a17-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=809&id=u0b3eeb04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=809&originWidth=556&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43301&status=done&style=none&taskId=uea4bb737-ce35-4551-8d5b-8195cc51cd3&title=&width=556)<br />还有一个边缘case我们需要处理下，我们输入测试用例 aabc 发现并没有匹配到，但其实是应该匹配到abc的，为什么呢，我们可以通过debug调试，发现第一次匹配到a时状态机变为了waitForB，此时匹配第二个字符还是a，并不是b，所以状态机会被重置为waitForA，那么接下来的字符是b，并不是a，所以状态机就一直是waitForA了，其实我们在waitForB时应当判断一下如果字符是a的话不应当重置为waitForB而是waitForA：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1652968726216-30136a0c-8eed-4cb3-855e-0de0bb8e73c5.png#clientId=u330f0a24-6a17-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=ucba16946&margin=%5Bobject%20Object%5D&name=image.png&originHeight=218&originWidth=418&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11186&status=done&style=none&taskId=ub853352f-a337-4c98-b492-793f5a1db70&title=&width=418)<br />这样我们就解决了一个边缘case，但其实这个实现肯定还是有缺陷的，这里就不再花时间深究了，只是了解一下有限状态机的原理及他和我们编译parse以及正则表达式的关系即可。
<a name="T3Nt8"></a>
#### 37.实现transform功能
之前我们实现的都是代码字符串parse转换为AST语法树的功能，这对于编译而言仅仅实现了第一步，现在我们要实现第二部transform，所谓transform就是对AST语法树进行一定规则的转换操作，比如修改AST节点的内容，属性等等，这一节我们简单实现一下改变text节点内容的功能，首先看测试：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653016915696-b4cfdd65-1e3c-4ed3-857d-1e66e4f59591.png#clientId=u3b528942-7bb9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=166&id=u0ef64460&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=661&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29741&status=done&style=none&taskId=u6d277f67-aef9-49c8-a7eb-2ac5470fbb2&title=&width=528.8)<br />我们写一个之前实现过的用例<div>hi,{{message}}</div>，先对他进行parse，拿到AST语法树后获取到text节点，执行transform方法，最终预期的效果是文本节点的内容被修改了。<br />实现transform方法其实不难，获取到ast root节点后，因为节点是一个树形结构，我们遍历树形结构一般有两种方法：广度优先搜索和深度优先搜索，这里我们使用深度优先搜索，其实就是用一个递归方法对这棵树进行遍历，找到text节点后修改他的内容即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653017541246-c9ffb0d5-900a-42f4-8f4a-92d20d90e45f.png#clientId=u3b528942-7bb9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=506&id=u534c46e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=633&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140270&status=done&style=none&taskId=u17412a92-3b7f-40cb-a033-d04329bdcbd&title=&width=548)<br />我们运行测试，发现text节点的content已经修改为了hi,mini-vue，但是这样的写法是不够好的，我们注意到，transform中递归遍历node的逻辑是相对稳定的，而修改text node的逻辑是灵活的，随时可变动的，我们需要对稳定的和可变的代码进行分离，把可变的代码抽离出来，由外部去传入，这也就是插件机制，我们给transform方法多设置一个参数options，里面有一个数组nodeTransforms，存放的用户写的plugin，我们在递归遍历树时，去循环遍历并执行nodeTransforms中的方法，这样我们就把易变动的代码抽离到了外部，用户可以自行决定传不传，传多少，我们的代码就变得非常灵活且扩展性强了：
```javascript
describe('transform', function () {
    it('happy path', function () {
        const ast = baseParse('<div>hi,{{message}}</div>')
        const plugin = (node) => {
            if (node.type === NodeTypes.TEXT) {
                node.content += 'mini-vue'
            }
        }
        transform(ast, {
            nodeTransforms: [plugin]
        })
        const textNode = ast.children[0].children[0]
        expect(textNode.content).toBe('hi,mini-vue')
    });
});
```
```javascript
export function transform(root, options) {
  //创建一个上下文存放root和options
  const context = createTransformContext(root, options)
  traverseNode(root, context)
}

function createTransformContext(root, options) {
  return {
    root,
    nodeTransforms: options.nodeTransforms || []
  }
}

//利用递归对ast树进行深度优先遍历
function traverseNode(node, context) {
  const {nodeTransforms} = context
  //通过插件机制将容易变动的代码抽离出去，由外部去实现
  //这样程序的扩展性就变得很强了，并且提高了程序的可测试性
  for (const transform of nodeTransforms) {
    transform(node)
  }
  traverseChildren(node, context)
}

function traverseChildren(node, context) {
  const children = node.children
  if (children) {
    for (let i = 0; i < children.length; i++) {
      traverseNode(children[i], context)
    }
  }
}
```
<a name="uPh8t"></a>
#### 38.实现text类型代码生成
这节开始我们要实现将AST语法树转换为代码的功能，vue对template的编译就是最终编译为render函数，我们可以在[vue-next-tempalte-explorer](https://template-explorer.vuejs.org/)这个网站上观察到我们写的template被编译后的最终效果，这节我们先来实现最简单的text类型render函数，首先我们修改右上角的options，简化右边render函数的生成效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653140996490-90728ca5-f74b-4280-8a15-16bc16951265.png#clientId=u893e835a-ef21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=340&id=u7bcccd3e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=355&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16051&status=done&style=none&taskId=u0ced6224-4b27-4380-8153-5300792d33e&title=&width=355)<br />并在网站左边输入一个最简单的文本hi，发现右边显示的render函数显示为：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653140972017-0dcbfa86-c33c-467f-8116-3b4a8595eca3.png#clientId=u893e835a-ef21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=238&id=u0171a16f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=238&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17117&status=done&style=none&taskId=uaf0bdd5c-5424-4db9-a3f1-0e61d8b1874&title=&width=1243)我们把右边render函数拷贝下来，作为我们单测实现的目标，这次我们稍微改一下单测的书写方式，我们新建一个generate方法，接收ast语法树生成代码，最后给这个代码打上一个快照，之后我们运行单测时，jest就会新建一个__snapshot__目录，里面存放一个我们这次测试结果的快照，之后再次测试时就会用结果与这个快照进行比 对，观察是否有变化，如果我们不想进行比对而想重新生成一次快照，可以给命令jest string加上-u的参数：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653141068063-a6ce0b0f-fbeb-455f-9e02-da6170196e5f.png#clientId=u893e835a-ef21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=202&id=u49d90028&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16149&status=done&style=none&taskId=u9e4c19c9-80a6-4e41-9470-eec30f4198c&title=&width=493)<br />接下来我们实现一下generate方法，这个方法放在codegen.ts中，我们首先伪实现一下，直接return一个字符串，就是我们从vue-next-template-explorer上粘贴的render函数字符串，我们运行测试，可以发现生成了快照：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653141452484-f3765fbd-954d-4ac4-8c5d-333f4cb11033.png#clientId=u893e835a-ef21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=89&id=uc5b75855&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5923&status=done&style=none&taskId=u1c292c53-274d-45cf-9bbc-bebea9de403&title=&width=820)<br />此时我们修改return结果，比如return 'hi 1'，再次执行单测就会发现报错了，并且jest指出了和快照中不一样的部分。接下来我们继续实现，我们其实就是要拼接一个render函数的代码字符串，我们把这段字符串分解为固定部分，函数名，函数参数，以及函数体部分，并且我们知道，return的'hi'就是text类型AST节点中的content，所以我们获取到text节点，取出content并返回即可：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653141685971-83c55181-07b6-43e6-b50e-77e46f96e177.png#clientId=u893e835a-ef21-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=231&id=u8a9d1743&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19115&status=done&style=none&taskId=ubc99eb24-976e-448b-9c8b-dfe39df438e&title=&width=513)<br />这样我们就实现了一个基本的generate，我们运行测试，可以看到和快照中我们预期的结果一致。<br />接下来我们重构一下代码，首先我们在生成函数体时获取的节点内容是通过ast.children[0]获取的，但是我们在generate中不应当去放置获取ast入口节点的内容，这部分内容应当放在transform中，所以我们在transform中新建一个方法，用这个方法给AST的root节点创建一个codegenNode属性，我们在generate函数中就读取这个属性当做生成代码的入口节点，这样我们代码的分工就变得清晰了：
```javascript
export function transform(root, options = {}) {
  //创建一个上下文存放root和options
  const context = createTransformContext(root, options)
  traverseNode(root, context)
  //创建一个codegenNode作为生成render函数的入口节点
  createCodegenNode(root)
}

function createCodegenNode(root){
  root.codegenNode = root.children[0]
}
```
我们在generate方法前调用一下transform方法，在generate中直接获取ast.codegenNode，而不用获取ast.children[0]了。<br />我们进一步优化代码，首先我们把根据ast生成函数体的代码抽离到一个genNode方法中，并且我们发现，我们一直在对一个变量code进行追加操作，所以我们可以类似之前parse和transform中的思想，创建一个全局上下文对象context，把code放在上下文对象中，之后我们所有的操作都可以基于这个全局上下文，并且我们可以把code中追加内容的操作也封装成一个push方法，最终代码就变成了：
```javascript
export function generate(ast) {
    const context = createCodegenContext()
    const {push} = context
    push('return ')
    const functionName = 'render'
    const args = ['_ctx', '_cache']
    const signature = args.join(', ')
    push(`function ${functionName} (${signature}) {`)
    genNode(ast.codegenNode, context)
    return {
        code: context.code
    }
}

function createCodegenContext() {
    const context = {
        code: '',
        push(source) {
            context.code += source
        }
    }
    return context
}

function genNode(node, context) {
    const {push} = context
    push(`return '${node.content}'}`)
}
```
我们运行测试，发现没问题，这样我们就优化了实现text类型render函数的generate方法。
<a name="wFt5J"></a>
#### 39.实现插值类型代码生成
这一节我们来实现插值类型的代码生成，首先还是去vue-next-template-explorer输入一段插值内容{{message}}，观察右边的输出：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653288777325-892cf6d4-5cda-44fb-9efc-f7caad9a61f2.png#clientId=u9e5c747d-a70e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=104&id=ub4f3aa25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=130&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12760&status=done&style=none&taskId=u2c5e03f3-ac44-431b-9b00-4d1682c6145&title=&width=649.6)<br />这一段就是我们需要实现的效果，对比我们之前实现的text类型render函数，我们发现多了一个import，也就是从Vue中结构赋值出toDisplayString方法这段，在函数体中调用了这个方法，并且参数是从_ctx中获取的模板表达式内容message，我们先写一个测试：
```javascript
 it('interpolation', function () {
   const ast = baseParse('{{message}}')
   const code = generate(ast)
   expect(code).toMatchSnapshot()
 });
```
首先我们先来实现import，我们在generate方法开头新增一个genFunctionPreamble方法，用来处理import，const解构赋值这些前导码，我们当然可以直接写死一个依赖数组，再遍历去拼接前导码，但是依赖不应当放在codegen里，这不符合代码分工，所以我们在transform中生成这个依赖数组：我们首先在transform的上下文context对象新增一个map helpers，用来存放需要导入的依赖名称，另外再新增一个方法helper用来添加helper：
```javascript
function createTransformContext(root, options) {
    const context = {
        root,
        helpers: new Map(),
        helper(key) {
            context.helpers.set(key, 1)
        },
        nodeTransforms: options.nodeTransforms || []
    }
    return context
}
```
有了这个helpers，我们就可以在遍历节点的时候调用，因为我们只有在遇到插值类型节点时才需要添加toDisplayString这个依赖，所以我们在遍历节点的时候加一个判断：
```javascript
//根据节点类型给ast添加需要导入的模块helpers
    switch (node.type) {
        case NodeTypes.INTERPOLATION:
            context.helper(TO_DISPLAY_STRING);
            break;
        //root和element类型节点才会有children
        case NodeTypes.ROOT:
        case NodeTypes.ELEMENT:
            traverseChildren(node, context)
            break;
        default:
            break;
    }
```
这里我们另外优化了一点，就是只有root节点和标签节点才会有children，所以我们吧traverseChildren提取到这两个节点的判断条件下执行，不要忘了在ast.ts中给NodeTypes新增一个ROOT枚举。此时全局context的helpers属性就有了我们需要的依赖，我们在transform遍历完节点在根节点新增一个helpers属性存放这些依赖：
```javascript
export function transform(root, options = {}) {
    //创建一个上下文存放root和options
    const context = createTransformContext(root, options)
    traverseNode(root, context)
    //创建一个codegenNode作为生成render函数的入口节点
    createCodegenNode(root)
    root.helpers = [...context.helpers.keys()]
}
```
这样我们在generate中就可以通过根节点的helpers获取到依赖，并生成相应的前导码代码：
```javascript
//处理前导码（import，const）这些
function genFunctionPreamble(ast, context) {
    const {push} = context
    const VueBinging = 'Vue'
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`
    if (ast.helpers.length > 0) {
        push(`const { ${ast.helpers.map(helper => aliasHelper(helper)).join(', ')} } = "${VueBinging}"`)
    }
    push('\n')
    push('return ')
}
```
处理完了前导码，接下来我们修改生成函数体的部分，也就是genNode方法，我们之前只处理了text类型节点，简单地把content追加到了函数体中，现在我们需要根据节点类型进行判断，如果遇到的是插值类型或表达式类型执行不同的方法：
```javascript
function genNode(node, context) {
    switch (node.type) {
        case NodeTypes.INTERPOLATION:
            genInterpolation(node, context)
            break;
        case NodeTypes.TEXT:
            genText(node, context);
            break;
        case NodeTypes.SIMPLE_EXPRESSION:
            genExpression(node, context)
            break;
        default:
            break;
    }
}
```
遇到插值时我们需要生成的函数体为return _toDisplayString(_ctx.message)，return是死的，直接push，后面我们需要调用_toDisplayString方法，而这个方法就是我们在上面导入的依赖，所以我们可以创建一个全局变量TO_DISPLAY_STRING来将这两者关联起来，我们新建一个runtimeHelper.ts：
```javascript
export const TO_DISPLAY_STRING = Symbol('toDisplayString')

export const helperNameMap = {
    [TO_DISPLAY_STRING]: 'toDisplayString'
}
```
因为我们最终拼接代码还是需要字符串而不是Symbol，所以我们要维护一个helperNameMap，这样我们通过helperNameMap[key]就可以拿到依赖方法真正的字符串名字，为了避免在每处都写一遍helperNameMap[key]，我们在codegen的上下文中新建一个helper方法，根据key来拼接方法名：
```javascript
function createCodegenContext() {
    const context = {
        code: '',
        push(source) {
            context.code += source
        },
        helper(key) {
            return `_${helperNameMap[key]}`
        }
    }
    return context
}
```
这样我们在genInterpolation中就可以通过Symbol拼接出方法名了：
```javascript
function genInterpolation(node, context) {
    const {push, helper} = context
    push(`${helper(TO_DISPLAY_STRING)}(`)
    genNode(node.content, context)
    push(')')
}
```
拼接出_toDisplayString方法名，里面的参数也需要进一步处理，根据AST结构，插值节点里面的content是一个表达式节点，我们可以继续调用genNode方法去处理，此时我们需要在表达式名字message前面加一个_ctx.，按照代码分工，这部分也不应该出现在codegen.ts中，而应当由transform处理，我们可以实现一个transform插件：
```javascript
export function transformExpression(node){
  if(node.type === NodeTypes.INTERPOLATION){
    node.content = processExpression(node.content)
  }
}

function processExpression(node){
  node.content = '_ctx.' + node.content
  return node
}
```
我们判断节点类型，如果是插值，那他的content是表达式类型，我们在表达式变量前添加一个_ctx.即可，这样我们在genExpression中直接追加content就行了：
```javascript
function genExpression(node, context) {
    const {push} = context
    push(`${node.content}`)
}
```
不要忘了在测试用例中的transform方法传入插件：
```javascript
it('interpolation', function () {
  const ast = baseParse('{{message}}')
  transform(ast,{
    nodeTransforms:[transformExpression]
  })
  const code = generate(ast)
  expect(code).toMatchSnapshot()
});
```
最后跑一遍测试，记得不仅仅要跑interpolation，所有测试都跑一遍以防修改的逻辑影响了之前的代码。
<a name="F7tdW"></a>
#### 40.实现element类型代码生成
这节我们继续实现element类型代码生成，在vue-next-template-explorer上输入<div></div>：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653360830193-9ebedc66-6148-4808-9c46-1e555a76d19f.png#clientId=ud824aece-085a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=177&id=u503d4e8b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16862&status=done&style=none&taskId=u8e6b19f4-66ce-464b-9239-d810d704942&title=&width=683.2)<br />在这里我们稍作区别，不需要用他的openBlock,createElementBlock等优化方法，只需要return一个_createElementVNode方法即可，还是老样子写个测试，此时观察到输出结果没有前导码也没有函数体，下面我们来实现，首先在transform里我们需要在节点类型为element时给context.helpers新增相应的依赖，我们去runtimeHelper.ts中新增一下依赖Symbol：
```javascript
export const TO_DISPLAY_STRING = Symbol('toDisplayString')
export const CREATE_ELEMENT_VNODE = Symbol('createElementVNode')

export const helperNameMap = {
    [TO_DISPLAY_STRING]: 'toDisplayString',
    [CREATE_ELEMENT_VNODE]: 'createElementVNode'
}
```
如果按之前的形式，我们需要在switch的NodeTypes.Element case下去新增helper，但是目前我们是把ROOT类型和ELEMENT类型当做一个条件判断的，如果再分开写不够优雅，所以我们可以通过写一个插件来实现：
```javascript
import {NodeTypes} from "../ast";
import {CREATE_ELEMENT_VNODE} from "../runtimeHelpers";

export function transformElement(node, context) {
    if (node.type === NodeTypes.ELEMENT) {
        context.helper(CREATE_ELEMENT_VNODE)
    }
}
```
通过插件实现添加helper，同时我们需要在调用插件方法的时候把context传出去：
```javascript
  for (const transform of nodeTransforms) {
        transform(node, context)
    }
```
最后我们修改一下codegen.ts，新增一个genElement方法生成函数体，逻辑和插值类似，只不过这里要通过node拿到tag名称：
```javascript
function genElement(node, context) {
    const {push, helper} = context
    const {tag} = node
    push(`${helper(CREATE_ELEMENT_VNODE)}(`)
    push(`"${tag}")`)
}
```
<a name="jx9pT"></a>
#### 41.实现三种联合类型代码生成
现在我们来实现<div>hi,{{message}}</div>这样的三种联合类型代码生成，生成的结果为：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653377971612-867151f3-c0d8-40a0-a873-8e96a52334ee.png#clientId=u2567eb91-ff75-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=ud716a19d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19568&status=done&style=none&taskId=u036e5fce-79c4-498b-b08d-f32b414e9a1&title=&width=765.6)<br />根据我们上节实现的element类型代码生成，我们修改一下genElement方法，首先拿到element节点的children：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653378045066-a8c921d0-6f38-4f5f-ba6e-7810805eae91.png#clientId=u2567eb91-ff75-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=86&id=u544154f1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=531&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8127&status=done&style=none&taskId=u7e920a43-35d6-480c-ac5f-b53ff1d74ce&title=&width=424.8)<br />我们遍历一下这个children数组，根据数组项再次执行genNode方法可以得到一个类似的结果：
```javascript
function genElement(node, context) {
    const {push, helper} = context
    const {tag, children} = node
    console.log('genElement------',children)
    push(`${helper(CREATE_ELEMENT_VNODE)}(`)
    push(`"${tag}" ,null, `)
    for(let i=0;i<children.length;i++){
        const child = children[i]
        genNode(child,context)
    }
    push(')')
}
```
此时快照输出的结果为：
```javascript
const { createElementVNode: _createElementVNode, toDisplayString: _toDisplayString } = \\"Vue\\"
return function render (_ctx, _cache) {return _createElementVNode(\\"div\\" ,null, 'hi,'_toDisplayString(message))}
```
我们注意到hi和插值方法之间少了一个+，并且插值表达式message应该改为_ctx.message，首先我们来补上+，+仅能出现在两个连续的text类型节点或者插值类型节点之间，所以我们不能无脑地在所有节点之间加上+。我们创建一个新的类型的节点复合表达式节点：
```javascript
export const enum NodeTypes {
    INTERPOLATION,
    SIMPLE_EXPRESSION,
    ELEMENT,
    TEXT,
    ROOT,
    COMPOUND_EXPRESSION
}
```
我们去遍历element节点的children，如果遇到两个相邻的文字类型节点（text类型或插值类型），我们就创建一个复合表达式节点，并将文字节点放到复合节点的children中，并删除这两个文字节点，最后我们在这两个文字节点中间加上+即可，我们创建一个插件transformText用来转换复合表达式节点：
```javascript
export function transformText(node) {
    if (node.type === NodeTypes.ELEMENT) {
        const {children} = node
        let currentContainer
        for (let i = 0; i < children.length; i++) {
            const child = children[i]
            if (isText(child)) {
                //检查文字节点的后一个节点
                for (let j = i + 1; j < children.length; j++) {
                    const next = children[j]
                    if (isText(next)) {
                        //如果出现了两个相邻的文字节点
                        if (!currentContainer) {
                            //如果currentContainer不存在，代表是child是复合节点的第一项
                            //创建一个复合节点，并把文本节点替换为复合节点，并把文本节点放到children里
                            currentContainer = children[i] = {
                                type: NodeTypes.COMPOUND_EXPRESSION,
                                children: [child]
                            }
                        }
                        //往复合节点的children里追加+和下一个文本节点
                        currentContainer.children.push(' + ')
                        currentContainer.children.push(next)
                        //从children中删除next节点，并且把下标前移一位，以防循环提前中止
                        children.splice(j, 1)
                        j--
                    } else {
                        //如果再下一个节点不是文本节点了，就重置currentContainer并跳出内层循环，重新开始寻找新的可能的复合节点
                        currentContainer = undefined
                        break
                    }
                }
            }
        }

    }
}
```
我们来分析这个方法：首先我们依次遍历node.children，如果当前节点child是文字节点，就继续从这个节点开始往后遍历，如果后一个节点是文字节点，我们就可以创建一个复合类型节点，并且把child加入他的children属性中，之后加入一个符号+，再把child后一个节点next也加入这个复合类型节点中，同时把这个复合节点赋值给children[i]，也就是替换掉child，并且也把next节点删掉，循环执行找next并追加到复合节点children的操作，直到发现不是文字类型的节点，就跳出当前循环并重置复合节点，简单地说，这个操作就是把一个数组改成一个二维数组：`[1,1,2,1,1,1,3] -> [[1,1],2,[1,1,1],3]` 把文本类型的节点组合到一个复合类型节点中去。<br />实现了transformText之后我们把这个插件加到测试案例中，并打印出AST树的codegenNode：
```javascript
it('element', function () {
        const ast:any = baseParse('<div>hi,{{message}}</div>')
        transform(ast,{
            nodeTransforms:[transformElement,transformText]
        })
        console.log('ast-----',ast.codegenNode.children)
        const code = generate(ast)
        expect(code).toMatchSnapshot()
    });
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653399979696-a1f1187e-8361-45cf-9638-6b4ce0ae5ebb.png#clientId=uf1d89e45-2178-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=65&id=u6776da85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=65&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3142&status=done&style=none&taskId=u7a6841a9-c5c9-49f4-899f-cb9df0a2d96&title=&width=617)<br />可以看到此时element的children是一个type为5(COMPOUND_EXPRESSION)类型的节点，并且他的children有三个值，分别为text类型节点，+，插值类型节点，有了这个复合类型节点，我们就可以改写codegen，新增一个genCompoundExpression方法用于处理复合类型节点：
```javascript
function genCompoundExpression(node,context){
    const {push} = context
    const {children} = node
    for (let i = 0; i < children.length; i++) {
        const child = children[i]
        if(isString(child)){//符号+直接push
            push(child)
        }else{//文字类型节点
            genNode(child, context)
        }
    }
}
```
因为复合节点的children是一个数组，所以我们直接遍历，他的children有两种情况，一种是字符串+，对于这种情况我们直接追加到函数体内，另外一种情况就是文字类型节点，我们直接调用genNode处理即可。这时候我们就可以修改genElement方法，在这个例子里element的子元素不再是数组了，而被我们聚合成了一个复合节点，所以我们不再遍历element.children，直接通过children[0]获取到复合节点再进行genNode操作即可，这时候问题就来了，获取children[0]这种操作不应当出现在codegen中，这也是我们之前一直在说的代码分工，所以我们来到transform中，改写transformElement这个插件：
```javascript
export function transformElement(node, context) {
    if (node.type === NodeTypes.ELEMENT) {
        context.helper(CREATE_ELEMENT_VNODE)
        //tag
        const vnodeTag = node.tag
        //props
        let vnodeProps
        //children
        const vnodeChildren = node.children[0]
        const vnodeElement = {
            type:NodeTypes.ELEMENT,
            tag:vnodeTag,
            props:vnodeProps,
            children:vnodeChildren
        }
        node.codegenNode = vnodeElement
    }
}
```
在这里我们创建了一个vnodeElement对象，把element节点的第一个child作为他的children属性，并且生成type,tag,props这些属性，最后把这个对象赋值给element的codegenNode属性。这个vnodeElement的作用是什么呢，我理解的就是他是作为生成element类型代码时的一个代理对象，也就是说如果我们之后遇到elemnet类型，读取的应该是他的codegenNode属性，而不是他本身上面的tag,children,props这些。所以我们需要在处理root节点的时候做一个判断，我们之前在给root.codegenNode赋值的时候用的都是root.children[0]，根据上面的原则，如果root的children[0]是一个element类型，就不能用它本身了，而应当用他的codegenNode：
```javascript
function createCodegenNode(root) {
    //获取root下的第一个节点，如果是element类型，就把element的codegenNode作为root的入口
    const child = root.children[0]
    if(child.type === NodeTypes.ELEMENT){
        root.codegenNode = child.codegenNode
    }else{
        root.codegenNode = root.children[0]
    }
}
```
并且我们在genElement的时候因为拿到的node是vnodeElement这个代理对象，他的children属性已经处理好了，是element本身的children[0]，我们这里就不必去拿children[0]了：
```javascript
function genElement(node, context) {
    const {push, helper} = context
    const {tag, children} = node
    push(`${helper(CREATE_ELEMENT_VNODE)}(`)
    push(`"${tag}" ,null, `)
    genNode(children,context)
    push(')')
}
```
写完以后我们跑下测试，发现是有问题的，生成的代码只打印出了'hi,'，后面的内容没了，这是为什么呢，我们可以观察一下此时的AST树，发现element节点下面的children只有一个文字节点hi，并不是我们期望的复合类型节点，原来我们在调用插件的时候顺序出现了问题，先进行了transformElement截取了children[0]，此时因为还没有进行transformText，复合类型节点还没生成，所以就出错了，我们修改下插件的执行顺序即可：
```javascript
transform(ast,{
  nodeTransforms:[transformText,transformElement]
})
```
此时我们运行测试，后面的插值内容已经有了，但是插值函数的参数应当为_ctx.message，我们还需要加上_ctx.，这个操作我们之前已经实现过了，利用transformExpression这个插件即可，所以我们在插件中加入：
```javascript
 transform(ast, {
   nodeTransforms: [transformExpression,transformText, transformElement]
 })
```
运行测试发现并没有加上_ctx，这很奇怪，我们明明在最前面加上了transformExpression插件，他应该是最新执行的才对，我们可以在transform.ts执行插件的地方打上断点，可以发现这个断点总共执行了三次，第一次noide的类型是root，第二次是element div，这都没问题，但是第三次node的类型是复合类型，并不是我们希望的文本类型，这是为什么呢，原来我们虽然保证了插件传入的顺序，但是这只是针对一个节点而言，我们在遍历节点执行插件的时候对一个节点执行完所有插件再进入下一个节点的处理，所以在处理element节点的时候由于执行了transformText插件，文本节点被聚合成了一个复合节点，而复合类型节点并不会进一步进行递归：
```javascript
//仅仅root和element类型再会继续往深处递归
case NodeTypes.ROOT:
case NodeTypes.ELEMENT:
traverseChildren(node, context)
break;
```
所以复合类型节点以及他的children都不会继续往下递归，也就没有走到遍历执行插件的断点了，所以我们该怎么做呢：我们要保证transformExpression插件必须优先执行，并且在他执行完之前，后面的transformText，transformElement插件都不能执行，所以我们可以这样写：
```javascript
function traverseNode(node, context) {
    const {nodeTransforms} = context
    let exitFns: any = []
    //通过插件机制将容易变动的代码抽离出去，由外部去实现
    //这样程序的扩展性就变得很强了，并且提高了程序的可测试性
    for (const transform of nodeTransforms) {
        const onExit = transform(node, context)
        if(onExit) exitFns.push(onExit)
    }
    //根据节点类型给ast添加需要导入的模块helpers
    switch (node.type) {
        case NodeTypes.INTERPOLATION:
            context.helper(TO_DISPLAY_STRING);
            break;
        //root和element类型节点才会有children
        case NodeTypes.ROOT:
        case NodeTypes.ELEMENT:
            traverseChildren(node, context)
            break;
        default:
            break;
    }
    let i = exitFns.length
    while (i--) {
        exitFns[i]()
    }
}
```
我们让需要推迟执行的插件函数不再是直接执行他的函数体，而是return一个函数，把函数体放到return的这个函数中，我们在执行插件的时候检查如果插件有返回值，就把他存放到一个数组中（先不执行），等递归遍历完整个node，再从后往前遍历执行这个数组中的方法，这样我们就保证了有返回值的插件方法永远会在没有返回值的插件方法后面执行。最后，不要忘了修改两个后执行的插件方法，改成return一个函数，以及在测试用例中传入插件时把他们调换顺序，因为我们最后遍历数组是从后往前遍历的，也就是先调用的插件后执行，<br />执行顺序为transformExpression -> transformElement ->  transformText<br />传入顺序为[transformExpression, transformElement, transformText]
```javascript
it('element', function () {
        const ast:any = baseParse('<div>hi,{{message}}</div>')
        transform(ast, {
            nodeTransforms: [transformExpression, transformElement, transformText]
        })
        // console.log('ast-----',ast.codegenNode.children)
        const code = generate(ast)
        expect(code).toMatchSnapshot()
    });
```
```javascript
export function transformElement(node, context) {
    if (node.type === NodeTypes.ELEMENT) {
        return () => {
            context.helper(CREATE_ELEMENT_VNODE)
            //tag
            const vnodeTag = node.tag
            //props
            let vnodeProps
            //children
            const vnodeChildren = node.children[0]
            const vnodeElement = {
                type:NodeTypes.ELEMENT,
                tag:vnodeTag,
                props:vnodeProps,
                children:vnodeChildren
            }
            node.codegenNode = vnodeElement
        }
    }
}
```
我们运行测试用例可以发现_ctx.有了，说明插件的执行顺序是正确的。<br />接下来我们处理一下props，我们现在没有给props设置值，所以element上的props属性为undefined，但是我们生成的render函数里应当为null，所以我们可以写一个转换方法来处理，并且对于element节点的tag,props,children我们都需要将不存在的属性转换为字符串'null'，所以这个转换方法接收一个数组参数：
```javascript
function genNullable(args) {
    return args.map(arg => arg || 'null')
}
```
拿到处理好的数组之后我们要对他进行generate，最终生成代码字符串，而我们现在genNode方法处理的都是单个节点，所以我们可以创建一个genNodeList方法处理node数组：
```javascript
function genNodeList(nodes, context) {
    const {push} = context
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i]
        if (isString(node)) {
            push(node)
        } else {
            genNode(node, context)
        }
        if (i < nodes.length - 1) {
            push(', ')
        }
    }
}
```
遍历这个nodes数组，拿到每一项node后进行判断，如果是字符串就直接追加，否则调用genNode方法，最后我们要在这些节点中间加上逗号，因为tag,props,children这些是作为_createElementVNode方法的参数，参数之间是需要逗号分隔的，我们判断一下，如果不是末尾就插入逗号，此时我们的genElement方法就变成了这样：
```javascript
function genElement(node, context) {
    const {push, helper} = context
    const {tag, children, props} = node
    push(`${helper(CREATE_ELEMENT_VNODE)}(`)
    genNodeList(genNullable([tag, props, children]), context)
    push(')')
}
```
我们执行测试，可以看到基本和我们想要的结果完全一致了，只是tag那边的div没有引号包裹，我们回到transformElement插件里，在那里定义vnodeTag时加上引号：
```javascript
const vnodeTag = `'${node.tag}'`
```
这样生成的代码就和我们预期的render函数代码完全一致了。
<a name="oQOWE"></a>
#### 42.实现编译template成render函数
上面我们已经实现了将一段template编译成render函数，现在我们就要实现组件上面写一个template属性，就能最终编译并传递给他的render方法，让我们的runtime-core调用到这个编译好的render函数，首先我们写一个example，html和main.js和之前的例子是一样的，App.js这样写：
```javascript
import {ref} from "../../lib/guide-mini-vue.esm.js";

export const App = {
    name:'App',
    template:`<div>hi, {{count}}</div>`,
    setup(){
        //count.value++观察update
        const count = window.count = ref(1)
        return {
            count
        }
    }
}
```
我们现在要用compiler模块，把template编译为render函数，然后赋值给组件instance的render属性，首先我们要来到compiler-core模块，把我们之前实现的parse,transform,generate这一套编译流程组合成一个compile方法暴露出去，我们新建一个compile.ts，把之前测试里写的代码拷贝过去修改一下：
```javascript
//暴露一个出口方法baseCompile
export function baseCompile(template: string) {
    const ast: any = baseParse(template)
    transform(ast, {
        nodeTransforms: [transformExpression, transformElement, transformText]
    })
    return generate(ast)
}
```
这个方法接收一个template字符串，最终return出去生成好的code字符串，同时我们在compile-core新建一个index.ts，作为统一的出口，把baseCompile暴露出去：
```javascript
export * from './compile'
```
接下来回想runtime-core的代码，我们是在component.ts的finishComponentSetup里对instance.render进行赋值的，那么我们是不是可以在这里调用baseCompile方法呢，答案是否定的，根据vue的设计原则，每个模块之间是有严格的依赖顺序关系的：<br />![](https://cdn.nlark.com/yuque/0/2022/png/23083224/1649211286319-b251116b-1551-4b11-b756-bbc028ca3902.png#crop=0&crop=0&crop=1&crop=1&from=url&id=GdmV6&margin=%5Bobject%20Object%5D&originHeight=467&originWidth=1088&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />runtime-dom依赖于runtime-core依赖于reactivity，也就是说runtime-core中只能够调用reactivity模块中的方法，不能够直接调用compiler-core中的方法，如果要调用也可以，需要单独在最外面的vue模块中实现。这样做的目的就是降低模块之间的耦合度，并且使得底层模块能够单独使用，比如：我们能单独使用vue的响应式模块，并且可以不依赖于vue的编译模块，只使用vue的运行时模块。<br />依照上面的原则，我们在vue最外层的模块，也就是src下面的index.ts中调用baseCompile方法，我们创建一个compileToFunction方法，接收template参数，调用baseCompile返回code，此时的code就是编译完的带引入依赖的字符串：
```javascript
const {toDisplayString: _toDisplayString, createElementVNode: _createElementVNode} = Vue
return function render(_ctx, _cache) {
    return _createElementVNode('div', null, 'hi,' + _toDisplayString(_ctx.message))
}
```
此时这个代码块是带有依赖Vue的，要如何传入这个依赖呢，我们可以构造一个方法，用参数传入依赖，并且这个依赖Vue就是我们的runtime-dom模块，它里面会暴露出toDisplayString,createElementVNode...方法，我们这里使用new Function的语法，通过函数的构造方法创建一个函数：
```javascript
import * as runtimeDom from './runtime-dom'
function compileToFunction(template){
    const {code} = baseCompile(template)
    //利用Function构造函数创建一个函数，参数名为Vue，函数体为我们通过compiler生成的代码字符串
    //然后我们执行这个方法，Vue参数即runtime-dom里面暴露出的createVNode...这些方法
    //这个方法返回一个function render，即instance.render需要的render函数
    const render = new Function('Vue',code)(runtimeDom)
    return render
}
```
Funciton构造方法的最后一个参数为函数体，就是我们编译生成的code，前面的参数均为函数参数，为了和函数体中保持一致，我们写作'Vue'，而这个参数实际就是runtime-dom，并且因为我们需要的是return出来的render函数，所以我们需要执行这个方法，得到返回值render函数并return出去，这样我们就得到了一个生成render函数的方法，但是我们不能在runtime-core中直接调用这个方法，这时候我们可以用一种依赖注入的机制来解决这个问题，我们首先在component.ts中定义一个变量compiler默认值为null，这个变量就来存放刚刚我们实现的compileToFunction方法，然后我们再实现一个注册compiler的方法registerRuntimeCompiler并暴露出去，留给vue模块去调用：
```javascript
let compiler
//暴露一个方法用来给编译函数compiler赋值
export function registerRuntimeCompiler(_compiler){
    compiler = _compiler
}
```
在index.ts中我们直接调用registerRuntimeCompiler，把registerRuntimeCompiler传进去：
```typescript
registerRuntimeCompiler(compileToFunction)
```
这样如果我们使用了vue模块，就会自动执行注册编译器的方法，从而在runtime-core中定义的compiler就有了值，之后我们去给instance.render赋值的时候就可以检查下，如果存在编译器compiler，就用编译器去编译template生成render函数，否则就还是用用户给的render方法：
```typescript
function finishComponentSetup(instance){
  const Component = instance.type
  //给instance设置render
  //如果有compiler函数并且用户没有提供render方法而提供了template模板，就执行编译template为render函数
  if(compiler && !Component.render){
    if(Component.template){
      Component.render = compiler(Component.template)
    }
  }
  instance.render = Component.render
}
```
这样我们就实现了将template通过compiler-core模块编译成为render方法，并且我们没有在runtime-core中调用compiler-core模块的方法，代码是低耦合的。<br />此时我们执行yarn build --watch，观察example页面效果，发现报错了，内容是这样的：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653577952821-e5e83d18-6060-40ab-8ce7-fe294fe9b333.png#clientId=u4c9eac84-cf40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=169&id=ue5556612&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30740&status=done&style=none&taskId=u6a668b5e-cc9e-4464-9891-da7b3c0b73b&title=&width=717)<br />我们通过_ctx.count获取的count，而我们之前都是通过this.xxx获取的state，_ctx作为render函数的第一个参数我们并没有传，所以我们要在给render函数指定this对象的是也一起指定一下第一个参数，其实他们都是同一个值，就是我们给instance上挂载的proxy代理对象：
```javascript
const {proxy} = instance
const subTree = (instance.subTree = instance.render.call(proxy,proxy))
```
继续观察结果，发现toDisplayString和createElementVNode方法还没有在runtime-core中定义，我们补一下：
```javascript
export function toDisplayString(value) {
    return String(value)
}
```
而createElementVNode方法其实就是我们实现的createVNode方法，我们给他起个别名并暴露出去：
```javascript
export {createVNode as createElementVNode}
```
这样我们就可以看到，页面没有报错了，并且渲染出了我们想要的结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/23083224/1653578324415-0ad49522-532d-4008-be25-b1dc30b8e207.png#clientId=u4c9eac84-cf40-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=191&id=uc192fd43&margin=%5Bobject%20Object%5D&name=image.png&originHeight=191&originWidth=592&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17506&status=done&style=none&taskId=u14109306-5f12-410a-b0b1-f0a8e15232f&title=&width=592)<br />我们可以在控制台调用count.value++，可以看到响应式变化也能引起页面更新，大功告成！<br />到这里我们vue3源码学习就结束了了，我们实现了响应式，运行时，编译这三个模块。
